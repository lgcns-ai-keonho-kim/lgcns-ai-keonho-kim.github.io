# 02. 폴백 구현 패턴

## 이 챕터에서 배우는 것

- 폴백 구현을 위한 핵심 구성 요소와 흐름
- LangGraph 그래프에서 실전 폴백 패턴을 적용하는 방법
- Pydantic을 활용한 출력 검증과 폴백 연동 방식
- Enum 기반 에러 코드/사용자 메시지 관리 방법

---

## 1. 폴백 구현 흐름(실전 구조)

폴백은 다음 4단계로 구성하는 것이 가장 안정적입니다.

1) **실패 감지**: 오류/검증/점수 신호 수집
2) **분류/정책 결정**: 실패 유형을 분류하고 대체 경로 선택
3) **대체 실행**: 폴백 경로 실행(모델 전환/기본값/캐시)
4) **응답 보정**: 사용자 메시지와 메타데이터 정리

이 흐름이 고정되면 폴백이 “일관된 기능”이 됩니다.

---

## 2. 폴백 구현 패턴(실전 중심)

### 1) 라우팅 기반 폴백
- 라우터 노드에서 실패 유형을 판별해 경로 전환
- 사용 시점: 경로가 명확하고 운영자가 흐름을 통제해야 할 때

### 2) 검증(Validator) 기반 폴백
- 출력이 스키마/규칙을 위반하면 대체 경로로 전환
- 사용 시점: JSON/구조화 출력이 중요한 서비스

### 3) 다단계 모델 전환
- 고품질 모델 실패 → 저비용 모델로 전환
- 사용 시점: 품질 우선 서비스 + 비용 한도가 있는 경우

### 4) 캐시/기본값 폴백
- 검색 실패나 도구 장애 시 캐시 또는 안전 기본값 사용
- 사용 시점: 빠른 응답이 최우선인 서비스

### 5) 점수 기반 폴백
- 결과 품질 점수가 낮으면 보완 경로로 전환
- 사용 시점: 평가 기준이 정의된 서비스(채점/랭킹)

### 6) 병렬 쿼럼 폴백
- 여러 결과를 병렬 생성 후 기준을 만족하는 결과만 채택
- 사용 시점: 안정성과 품질이 최우선이며 비용을 감수할 수 있을 때

---

## 3. Pydantic 기반 검증 폴백 예시

LangGraph에서는 **모델 출력이 스키마를 지키는지**가 가장 큰 불안 요소입니다.
Pydantic은 이를 구조적으로 해결합니다.
검증 실패는 **에러 코드로 변환**해 사용자 메시지 정책과 연결하면 운영이 훨씬 안정적입니다.

```python
"""
목적: 모델 출력이 구조를 지키지 못하면 폴백 경로로 전환한다.
설명: Pydantic 검증 실패를 폴백 트리거로 사용한다.
디자인 패턴: Validator
참조: docs/01_langgraph_to_service/02_폴백_구현_패턴.md
"""

from dataclasses import dataclass
from pydantic import BaseModel, Field, ValidationError


class SummaryOutput(BaseModel):
    """요약 결과 스키마를 정의한다."""

    title: str = Field(min_length=3)
    bullets: list[str] = Field(min_length=1, max_length=5)


@dataclass(frozen=True)
class OutputValidator:
    """모델 출력 검증을 수행한다."""

    def validate(self, payload: dict) -> SummaryOutput:
        """스키마 검증을 수행한다.

        Args:
            payload: 모델 출력 데이터.

        Returns:
            SummaryOutput: 검증된 출력.
        """
        return SummaryOutput.model_validate(payload)


@dataclass(frozen=True)
class FallbackHandler:
    """검증 실패 시 안전 폴백으로 전환한다."""

    def run(self, payload: dict) -> dict:
        """검증 실패를 폴백으로 전환한다.

        Returns:
            dict: 폴백 결과.
        """
        try:
            validated = OutputValidator().validate(payload)
            return validated.model_dump()
        except ValidationError:
            return {
                "title": "요약 실패",
                "bullets": ["출력 형식 오류로 간단 요약을 제공합니다."],
            }
```

---

## 4. Enum 기반 에러 코드/사용자 메시지 관리 패턴

사용자 메시지 관리를 문자열로 분산시키면 **로그/지표/운영 정책**이 흔들립니다.
아래 예시는 **Enum 하나로 에러 코드와 사용자 메시지를 함께 관리**합니다.

```python
"""
목적: 에러 코드와 사용자 메시지를 분리해 일관성을 보장한다.
설명: Enum 내부에 사용자 메시지를 포함한다.
디자인 패턴: Value Object
"""

from enum import Enum


class ErrorCode(Enum):
    """서비스 전역에서 사용하는 에러 코드."""

    VALIDATION = ("validation_error", "출력 형식 오류로 간단 요약을 제공합니다.")
    TOOL = ("tool_error", "외부 도구 호출에 실패했습니다. 기본 안내만 제공합니다.")
    RETRIEVAL_EMPTY = ("retrieval_empty", "관련 정보를 찾지 못했습니다. 일반 설명을 제공합니다.")
    TIMEOUT = ("timeout", "처리가 지연되었습니다. 잠시 후 다시 시도해 주세요.")
    UNKNOWN = ("unknown_error", "처리 중 문제가 발생했습니다. 잠시 후 다시 시도해 주세요.")

    @property
    def code(self) -> str:
        """에러 코드 문자열을 반환한다."""
        return self.value[0]

    @property
    def user_message(self) -> str:
        """사용자 메시지를 반환한다."""
        return self.value[1]
```

### 사용 흐름 예시(실전 중심)

검증 실패를 **에러 코드로 변환**하고, 정책에서 사용자 메시지를 가져와 폴백 결과에 포함합니다.

```python
"""
목적: 검증 실패를 에러 코드로 변환해 사용자 메시지를 구성한다.
설명: Pydantic 검증 실패를 폴백 응답으로 연결한다.
디자인 패턴: Value Object
"""

from dataclasses import dataclass
from pydantic import ValidationError


@dataclass(frozen=True)
class ValidationFallbackService:
    """검증 실패를 폴백 응답으로 변환한다."""

    def handle(self, payload: dict) -> dict:
        """검증 실패 시 사용자 메시지를 포함한 응답을 만든다."""
        try:
            validated = OutputValidator().validate(payload)
            return {
                "status": "ok",
                "result": validated.model_dump(),
            }
        except ValidationError:
            error_code = ErrorCode.VALIDATION
            return {
                "status": "fallback",
                "error_code": error_code.code,
                "user_message": error_code.user_message,
                "result": {
                    "title": "요약 실패",
                    "bullets": [error_code.user_message],
                },
            }
```

---

## 5. 폴백 정책 설정 예시(구성 모델)

폴백 정책을 코드에 하드코딩하지 않고 **구성 모델로 분리**하면 운영이 쉬워집니다.
아래는 Pydantic으로 정책을 구조화하는 예시입니다.

```python
"""
목적: 폴백 정책을 구성 모델로 정의한다.
설명: 실패 유형별 경로와 메시지를 분리한다.
디자인 패턴: Policy
"""

from pydantic import BaseModel


class FallbackRule(BaseModel):
    """실패 유형별 폴백 규칙"""

    failure_type: str
    next_route: str
    message: str


class FallbackPolicyConfig(BaseModel):
    """폴백 정책 집합"""

    rules: list[FallbackRule]

    def find_route(self, failure_type: str) -> FallbackRule | None:
        """실패 유형에 맞는 규칙을 찾는다."""
        for rule in self.rules:
            if rule.failure_type == failure_type:
                return rule
        return None
```

---

## 6. 폴백 설계 시 자주 놓치는 포인트

- **중복 폴백**: 폴백 경로에서 다시 동일 실패 반복
- **비용 역전**: 폴백이 정상 경로보다 비싼 구조
- **과도한 사용자 메시지**: 사용자에게 불안만 주는 에러 안내
- **지표 부재**: 폴백 비율을 모니터링하지 않음

---

## 7. 구현 체크리스트

- 실패 감지 신호가 코드에 반영되어 있는가?
- 폴백 정책이 구성 가능한 형태로 분리되어 있는가?
- 검증 실패가 실제 폴백으로 연결되는가?
- 에러 코드와 사용자 메시지가 Enum으로 일관되게 관리되는가?
- 폴백 경로가 비용/시간 상한을 지키는가?
- 폴백 결과가 사용자 경험을 해치지 않는가?
