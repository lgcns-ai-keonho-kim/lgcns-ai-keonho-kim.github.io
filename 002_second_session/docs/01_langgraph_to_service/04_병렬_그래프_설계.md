# 04. 병렬 그래프 설계

## 이 챕터에서 배우는 것

- 병렬 노드 배치의 설계 원칙
- 팬아웃/팬인 구조를 안정적으로 유지하는 방법
- 병렬 결과 병합(merge) 전략
- 노드 내부 병렬과 LLM 병렬 호출 패턴
- 합류 정책(배리어/부분 실패)의 의미와 실전 설계 예시

---

## 1. 병렬 그래프 설계 원칙

- 분기 기준: 입력을 독립적으로 처리할 수 있는가?
- 합류 기준: 어떤 결과를 최종 응답에 반영할 것인가?
- 실패 기준: 부분 실패를 허용할 것인가?

그래프 설계는 **작업 분해보다 합류 설계가 더 중요**합니다.

---

## 2. 팬아웃/팬인 구조

- 팬아웃: 동일 입력을 여러 분석 노드로 분산
- 팬인: 결과를 합쳐 최종 출력 생성

팬인 단계에서는 **결과 충돌**, **지연**, **품질 불일치**를 다뤄야 합니다.

---

## 3. 주니어를 위한 합류 이해

합류 노드는 단순히 “모아서 합친다”가 아니라 **정책을 적용하는 지점**입니다.

- **무엇을 합칠지**: 어떤 결과가 신뢰 가능한가?
- **무엇을 버릴지**: 실패/지연 결과를 어떻게 제외할 것인가?
- **무엇을 기록할지**: 실패 사유/메타데이터를 남길 것인가?

즉, 합류는 **서비스 품질과 운영 안정성을 결정하는 핵심 설계**입니다.

---

## 4. 합류 조건(배리어)과 부분 실패 정책

실전에서는 **합류 시점과 실패 허용 기준**을 명확히 해야 합니다.

- **배리어(Barrier)**: 필수 결과가 모두 준비됐는지 확인
- **부분 실패 정책**: 일부 실패를 허용할지 결정

### 배리어 + 부분 실패 체크 예시

```python
"""
목적: 합류 전에 필수 결과와 실패 기준을 확인한다.
설명: 배리어가 충족되면 합류, 아니면 대체 경로로 분기한다.
디자인 패턴: Guard, Policy
"""

from dataclasses import dataclass


@dataclass(frozen=True)
class JoinGuard:
    """합류 조건을 검사한다."""

    required_keys: set[str]
    max_failures: int

    def can_join(self, results: dict[str, object], errors: list[str]) -> bool:
        """합류 가능 여부를 판단한다."""
        has_all = self.required_keys.issubset(results.keys())
        return has_all and len(errors) <= self.max_failures
```

---

## 5. 병렬 설계 패턴(상황별)

- **분할 처리(Map-Reduce)**: 입력을 쪼개 병렬 처리 후 요약/결합
- **앙상블+검증**: 여러 답변 생성 후 검증 노드로 최종 선택
- **레이스(스펙 서킷)**: 가장 빠른 결과를 채택하고 나머지 취소
- **쿼럼(Quorum) 기반**: 일정 개수 이상 일치하면 결과 확정
- **이중화 백업**: 실패 대비 대체 노드를 병렬로 실행

서비스 특성에 따라 **속도/품질/비용** 중 우선순위를 정해야 합니다.

---

## 6. 노드 내부 병렬(LLM 병렬 호출)

병렬은 노드 밖뿐 아니라 **노드 안에서 LLM을 동시에 호출**하는 형태로도 사용됩니다.

- 프롬프트 변형을 여러 개 실행해 최적 답 선택
- 동일 입력을 다중 모델로 호출해 앙상블
- 초안 생성과 검증 질문 생성을 동시 수행

노드 내부 병렬은 **그래프 복잡도를 늘리지 않으면서 품질을 높이는 전략**입니다.

---

## 7. 병렬 제어 정책(운영 관점)

- **동시성 제한**: 최대 병렬 호출 수를 제한해 비용 폭주 방지
- **타임아웃 정책**: 늦는 작업을 중단하고 부분 결과 합류
- **취소 전략**: 최종 결과가 확정되면 나머지 작업 취소
- **예산 정책**: 토큰/비용 상한을 넘으면 낮은 등급 경로로 전환

병렬 설계는 성능뿐 아니라 **운영 안정성**을 함께 설계해야 합니다.

---

## 8. 병합 전략(리듀서 패턴)

- 선호도 기반 병합: 우선순위 높은 결과를 선택
- 합성 병합: 여러 결과를 요약해 결합
- 필터 병합: 규칙에 맞는 결과만 유지
- 쿼럼 병합: 일정 개수 이상 일치하면 확정

---

## 9. LangGraph 실전 설계 예시

### 예시 A: 다중 후보 생성 + 검증 + 점수 기반 선택

```python
"""
목적: 여러 후보를 병렬 생성하고 검증/스코어링으로 최종 답을 선택한다.
설명: 팬아웃(후보 생성) → 팬인(검증/스코어링) → 선택 흐름이다.
디자인 패턴: Pipeline, Reducer, Policy
"""

from typing import TypedDict
from langgraph.graph import StateGraph, END


class QAState(TypedDict):
    question: str
    candidate_a: str
    candidate_b: str
    candidate_c: str
    scores: dict[str, float]
    answer: str


async def gen_a(state: QAState) -> dict:
    return {"candidate_a": await call_llm_variant(state["question"], "fast")}


async def gen_b(state: QAState) -> dict:
    return {"candidate_b": await call_llm_variant(state["question"], "balanced")}


async def gen_c(state: QAState) -> dict:
    return {"candidate_c": await call_llm_variant(state["question"], "accurate")}


async def score_candidates(state: QAState) -> dict:
    scores = await judge_model_score(
        question=state["question"],
        candidates={
            "a": state["candidate_a"],
            "b": state["candidate_b"],
            "c": state["candidate_c"],
        },
    )
    return {"scores": scores}


def select_best(state: QAState) -> dict:
    best_key = max(state["scores"], key=state["scores"].get)
    best_value = {
        "a": state["candidate_a"],
        "b": state["candidate_b"],
        "c": state["candidate_c"],
    }[best_key]
    return {"answer": best_value}


graph = StateGraph(QAState)
graph.add_node("fanout", lambda s: s)
graph.add_node("gen_a", gen_a)
graph.add_node("gen_b", gen_b)
graph.add_node("gen_c", gen_c)
graph.add_node("score", score_candidates)
graph.add_node("select", select_best)

graph.set_entry_point("fanout")
graph.add_edge("fanout", "gen_a")
graph.add_edge("fanout", "gen_b")
graph.add_edge("fanout", "gen_c")
graph.add_edge("gen_a", "score")
graph.add_edge("gen_b", "score")
graph.add_edge("gen_c", "score")
graph.add_edge("score", "select")
graph.add_edge("select", END)
```

실전에서는 `score` 노드가 **모든 후보가 모였는지 확인**한 뒤 실행되도록  
조건 분기나 상태 검사(배리어)를 두는 것이 안전합니다.

### 예시 B: 레이스 + 품질 게이트 (빠른 경로 vs 정확한 경로)

```python
"""
목적: 빠른 경로와 정확한 경로를 병렬 실행해 품질 조건을 만족하면 즉시 종료한다.
설명: 빠른 결과가 기준을 넘으면 종료, 아니면 느린 경로를 채택한다.
디자인 패턴: Race, Policy
"""

from typing import TypedDict
from langgraph.graph import StateGraph, END


class RaceState(TypedDict):
    query: str
    fast_answer: str
    slow_answer: str
    answer: str


async def fast_path(state: RaceState) -> dict:
    return {"fast_answer": await call_llm_fast(state["query"])}


async def slow_path(state: RaceState) -> dict:
    return {"slow_answer": await call_llm_accurate(state["query"])}


def choose_answer(state: RaceState) -> dict:
    if is_good_enough(state["fast_answer"]):
        return {"answer": state["fast_answer"]}
    return {"answer": state["slow_answer"]}


graph = StateGraph(RaceState)
graph.add_node("fanout", lambda s: s)
graph.add_node("fast", fast_path)
graph.add_node("slow", slow_path)
graph.add_node("choose", choose_answer)

graph.set_entry_point("fanout")
graph.add_edge("fanout", "fast")
graph.add_edge("fanout", "slow")
graph.add_edge("fast", "choose")
graph.add_edge("slow", "choose")
graph.add_edge("choose", END)
```

실전에서는 **빠른 결과가 기준을 넘으면 느린 경로를 취소/무시**하는 정책을 두거나,  
`choose` 노드가 두 결과를 모두 확인할 수 있도록 합류 조건을 설계합니다.

---

## 10. 병합 정책 예시(개념 코드)

아래 코드는 병렬 결과를 병합하는 리듀서(Reducer) 예시입니다.

```python
"""
목적: 병렬 결과를 하나의 응답으로 병합한다.
설명: 우선순위 기반 병합 정책을 제공한다.
디자인 패턴: Reducer
"""

from dataclasses import dataclass


@dataclass(frozen=True)
class MergePolicy:
    """병렬 결과 병합 정책을 정의한다."""

    preferred_key: str

    def merge(self, results: dict[str, str]) -> str:
        """병렬 결과를 병합한다.

        Args:
            results: 노드별 결과 딕셔너리.

        Returns:
            str: 병합된 최종 결과.
        """
        if self.preferred_key in results:
            return results[self.preferred_key]
        if results:
            return next(iter(results.values()))
        return "결과가 없습니다."
```

---

## 11. 사용 흐름 예시(개념)

병렬 결과를 모아 **우선순위 정책으로 합류**하는 흐름입니다.

```python
"""
목적: 병렬 결과를 병합 정책으로 정리한다.
설명: 우선순위 키로 최종 결과를 결정한다.
디자인 패턴: Reducer
"""

from dataclasses import dataclass


@dataclass(frozen=True)
class MergeService:
    """병합 정책을 실행한다."""

    policy: MergePolicy

    def run(self, results: dict[str, str]) -> str:
        """정책에 따라 병합 결과를 반환한다."""
        return self.policy.merge(results)
```

---

## 12. 구현 체크리스트

- 병렬 노드 간 입력/출력 의존성이 없는가?
- 병합 정책이 명확히 정의되어 있는가?
- 지연이 큰 노드를 별도로 분리했는가?
- 부분 실패 시 사용자 메시지가 준비되어 있는가?
- 노드 내부 병렬(LLM 다중 호출) 전략이 정의되어 있는가?
- 합류 배리어 조건과 부분 실패 허용 기준이 문서화되어 있는가?
