# 05. 상태 전이

## 이 챕터에서 배우는 것

- 상태 전이를 설계할 때 고려해야 할 기준
- Enum 기반 전이와 조건/정책 기반 전이의 차이
- 점수 기반·동적 라우팅의 사용 시점
- LangGraph에서 상태 전이를 구현하는 실전 패턴
- 전이 로그/관측 설계 포인트
- 상태 전이와 폴백/에러 코드 연동 방법
- 실전 상태 전이 시나리오 설계

---

## 1. 상태 전이가 중요한 이유

LangGraph의 핵심은 **노드 간 흐름 제어**입니다.
상태 전이가 불명확하면 다음 문제가 생깁니다.

- 예측 불가능한 경로 선택
- 디버깅 난이도 상승
- 폴백 흐름의 누락

따라서 상태 전이는 **명시적인 규칙과 정책**으로 관리해야 합니다.

---

## 2. 주니어를 위한 개념 정리

- **상태(State)**: 그래프가 “현재 어디에 있는지”를 설명하는 값
- **전이(Transition)**: 현재 상태에서 다음 상태로 이동하는 규칙
- **가드(Guard)**: 전이가 가능한지 사전에 확인하는 조건
- **라우터(Router)**: 여러 후보 경로 중 하나를 선택하는 로직

전이는 “코드가 알아서 흐르는 것”이 아니라, **명시적으로 설계해야 하는 정책**입니다.

---

## 3. 상태 전이 방식 비교

- **Enum 기반 전이**: 상태와 전이 표를 고정해 예측 가능성을 확보
- **조건 기반 전이**: 입력/중간 상태에 따라 Guard 조건으로 분기
- **정책 객체 전이**: 전이 로직을 별도 객체로 분리해 유지보수성 강화
- **점수 기반 전이**: 신뢰도/품질 점수로 경로 선택
- **동적 라우팅**: 실행 중에 경로를 변경해 최적 결과를 탐색

---

## 4. 전이표(Transition Table) 먼저 작성하기

상태 전이는 **표로 먼저 정리**하는 것이 가장 안전합니다.

| 현재 상태 | 조건 | 다음 상태 | 비고 |
|---|---|---|---|
| START | 항상 | RETRIEVE | 기본 경로 |
| RETRIEVE | score < 0.4 | FALLBACK | 품질 부족 |
| RETRIEVE | score >= 0.4 | GENERATE | 정상 경로 |
| GENERATE | score < 0.6 | FALLBACK | 품질 부족 |
| GENERATE | score >= 0.6 | END | 정상 종료 |

표를 만들면 **누락 경로/폴백 경로**를 빠르게 확인할 수 있습니다.

---

## 5. Enum 기반 전이 예시(개념 코드)

```python
"""
목적: 상태 전이를 Enum 기반으로 고정한다.
설명: 전이 표를 코드에 명시적으로 반영한다.
디자인 패턴: State, Policy
"""

from dataclasses import dataclass
from enum import Enum


class GraphState(Enum):
    """그래프 상태를 명시적으로 정의한다."""

    START = "start"
    RETRIEVE = "retrieve"
    GENERATE = "generate"
    FALLBACK = "fallback"
    END = "end"


@dataclass(frozen=True)
class TransitionTable:
    """정적 전이 규칙을 제공한다."""

    def next_state(self, state: GraphState, score: float) -> GraphState:
        """현재 상태와 점수로 다음 상태를 결정한다."""
        if state == GraphState.START:
            return GraphState.RETRIEVE
        if state == GraphState.RETRIEVE and score < 0.4:
            return GraphState.FALLBACK
        if state == GraphState.RETRIEVE:
            return GraphState.GENERATE
        if state == GraphState.GENERATE and score < 0.6:
            return GraphState.FALLBACK
        return GraphState.END
```

---

## 6. 조건(가드) 기반 전이 예시

조건 기반 전이는 **전이 가능 여부를 명확히 분리**합니다.

```python
"""
목적: 가드 조건으로 전이 가능 여부를 판단한다.
설명: 전이 조건을 함수로 분리해 테스트 가능하게 만든다.
디자인 패턴: Guard
"""

from dataclasses import dataclass


@dataclass(frozen=True)
class RetrieveGuard:
    """리트리벌 결과가 충분한지 검사한다."""

    min_docs: int

    def is_ok(self, docs: list[str]) -> bool:
        """문서 개수가 충분한지 확인한다."""
        return len(docs) >= self.min_docs
```

---

## 7. 점수 기반·동적 라우팅 예시

점수 기반 전이는 **품질/비용/지연** 같은 신호를 활용합니다.
동적 라우팅은 **실행 중 환경 변화**(레이트 리밋, 비용 초과 등)를 반영합니다.

```python
"""
목적: 점수/비용/지연을 종합해 경로를 선택한다.
설명: 정책 객체로 동적 라우팅을 수행한다.
디자인 패턴: Policy, Strategy
"""

from dataclasses import dataclass


@dataclass(frozen=True)
class RoutingSignals:
    """라우팅에 필요한 신호를 묶는다."""

    score: float
    cost: float
    latency_ms: int
    tool_available: bool


@dataclass(frozen=True)
class DynamicRoutingPolicy:
    """신호를 기반으로 동적 라우팅을 수행한다."""

    def decide(self, signals: RoutingSignals) -> str:
        """경로 이름을 반환한다."""
        if not signals.tool_available:
            return "fallback"
        if signals.score < 0.5:
            return "repair"
        if signals.cost > 1.0 or signals.latency_ms > 2000:
            return "cheap_path"
        return "high_quality"
```

---

## 8. 상태 전이와 폴백/에러 코드 연동

상태 전이는 **폴백/에러 코드와 반드시 연결**되어야 합니다.  
그래야 운영 로그, 사용자 메시지, 모니터링 지표가 일관됩니다.

```python
"""
목적: 실패 유형을 에러 코드로 변환하고 전이를 결정한다.
설명: 전이 결과에 에러 코드/사용자 메시지를 함께 담는다.
디자인 패턴: Policy, Value Object
"""

from dataclasses import dataclass
from enum import Enum


class FailureType(Enum):
    """실패 유형을 정의한다."""

    NONE = "none"
    RETRIEVAL_EMPTY = "retrieval_empty"
    VALIDATION_ERROR = "validation_error"
    TOOL_ERROR = "tool_error"
    TIMEOUT = "timeout"
    LOW_QUALITY = "low_quality"


class ErrorCode(Enum):
    """에러 코드를 정의한다."""

    RETRIEVAL_EMPTY = ("retrieval_empty", "관련 정보를 찾지 못했습니다. 일반 설명을 제공합니다.")
    VALIDATION = ("validation_error", "출력 형식 오류가 발생했습니다. 간단 요약을 제공합니다.")
    TOOL = ("tool_error", "외부 도구 호출에 실패했습니다. 기본 안내만 제공합니다.")
    TIMEOUT = ("timeout", "처리가 지연되었습니다. 잠시 후 다시 시도해 주세요.")
    LOW_QUALITY = ("low_quality", "품질 기준 미달로 보완 경로로 전환합니다.")
    UNKNOWN = ("unknown_error", "처리 중 문제가 발생했습니다. 잠시 후 다시 시도해 주세요.")

    @property
    def code(self) -> str:
        """에러 코드 문자열을 반환한다."""
        return self.value[0]

    @property
    def user_message(self) -> str:
        """사용자 메시지를 반환한다."""
        return self.value[1]


@dataclass(frozen=True)
class TransitionDecision:
    """전이 결과를 캡슐화한다."""

    next_state: GraphState
    error_code: ErrorCode | None
    user_message: str | None


@dataclass(frozen=True)
class TransitionWithFallbackPolicy:
    """폴백/에러 코드를 포함한 전이 정책."""

    def decide(self, state: GraphState, failure: FailureType, score: float) -> TransitionDecision:
        """전이와 에러 코드를 함께 결정한다."""
        if failure != FailureType.NONE:
            error_code = {
                FailureType.RETRIEVAL_EMPTY: ErrorCode.RETRIEVAL_EMPTY,
                FailureType.VALIDATION_ERROR: ErrorCode.VALIDATION,
                FailureType.TOOL_ERROR: ErrorCode.TOOL,
                FailureType.TIMEOUT: ErrorCode.TIMEOUT,
                FailureType.LOW_QUALITY: ErrorCode.LOW_QUALITY,
            }.get(failure, ErrorCode.UNKNOWN)
            return TransitionDecision(GraphState.FALLBACK, error_code, error_code.user_message)

        if state == GraphState.RETRIEVE and score < 0.4:
            return TransitionDecision(GraphState.FALLBACK, ErrorCode.LOW_QUALITY, ErrorCode.LOW_QUALITY.user_message)

        if state == GraphState.START:
            return TransitionDecision(GraphState.RETRIEVE, None, None)
        if state == GraphState.RETRIEVE:
            return TransitionDecision(GraphState.GENERATE, None, None)
        return TransitionDecision(GraphState.END, None, None)
```

전이 로직은 **실패 유형 → 에러 코드 → 사용자 메시지** 흐름으로 연결됩니다.  
이렇게 하면 폴백 메시지와 로그, 지표가 일관됩니다.

---

## 9. 실전 상태 전이 시나리오(중급/고급)

### 시나리오 A: 다중 리트리벌 + 품질 미달 폴백

- **상태 흐름**: START → RETRIEVE → (LOW_QUALITY) → FALLBACK → END  
- **핵심 포인트**: 리랭크 점수 < 0.4면 안전 요약 경로로 전환

### 시나리오 B: 도구 장애 + 캐시 폴백

- **상태 흐름**: START → TOOL_CALL → (TOOL_ERROR) → FALLBACK → END  
- **핵심 포인트**: 도구 실패 시 캐시/기본 응답으로 폴백

### 시나리오 C: 레이트 리밋 + 저비용 경로 전환

- **상태 흐름**: START → GENERATE → (TIMEOUT) → CHEAP_PATH → END  
- **핵심 포인트**: 타임아웃 발생 시 저비용 모델로 전환

각 시나리오는 **전이표 + 에러 코드 정책**으로 관리하는 것이 운영에 가장 안정적입니다.

### 시나리오 A 실전 코드(요약)

```python
"""
목적: 리트리벌 품질 미달 시 폴백으로 전환한다.
설명: 실패 유형을 에러 코드로 변환해 상태에 기록한다.
디자인 패턴: Policy, Guard
"""

from typing import TypedDict
from langgraph.graph import StateGraph, END


class SupportState(TypedDict):
    query: str
    docs: list[str]
    score: float
    failure_type: str
    route: str
    error_code: str | None
    user_message: str | None
    answer: str


async def retrieve_node(state: SupportState) -> dict:
    docs = await search_a(state["query"])
    failure = FailureType.RETRIEVAL_EMPTY if not docs else FailureType.NONE
    return {"docs": docs, "failure_type": failure.value}


def score_node(state: SupportState) -> dict:
    score = evaluate_quality(state["docs"])
    failure = FailureType.LOW_QUALITY if score < 0.4 else FailureType.NONE
    return {"score": score, "failure_type": failure.value}


def router_node(state: SupportState) -> dict:
    policy = TransitionWithFallbackPolicy()
    failure = FailureType(state["failure_type"])
    decision = policy.decide(GraphState.RETRIEVE, failure, state["score"])
    return {
        "route": decision.next_state.value,
        "error_code": decision.error_code.value if decision.error_code else None,
        "user_message": decision.user_message,
    }


async def generate_node(state: SupportState) -> dict:
    answer = await call_llm_with_context(state["query"], state["docs"])
    return {"answer": answer}


def fallback_node(state: SupportState) -> dict:
    return {"answer": state["user_message"] or "기본 안내를 제공합니다."}


graph = StateGraph(SupportState)
graph.add_node("retrieve", retrieve_node)
graph.add_node("score", score_node)
graph.add_node("router", router_node)
graph.add_node("generate", generate_node)
graph.add_node("fallback", fallback_node)

graph.set_entry_point("retrieve")
graph.add_edge("retrieve", "score")
graph.add_edge("score", "router")
graph.add_conditional_edges("router", lambda s: s["route"], {
    "generate": "generate",
    "fallback": "fallback",
})
graph.add_edge("generate", END)
graph.add_edge("fallback", END)

app = graph.compile()
```

---

## 10. LangGraph에서 전이 구현 패턴(실전)

### 예시 A: 조건 기반 전이(Guard 활용)

```python
"""
목적: 리트리벌 결과 수에 따라 경로를 분기한다.
설명: 가드 조건을 라우터 노드에 적용한다.
디자인 패턴: Guard, Policy
"""

from typing import TypedDict
from langgraph.graph import StateGraph, END


class GuardState(TypedDict):
    query: str
    docs: list[str]
    route: str


def route_by_docs(state: GuardState) -> str:
    guard = RetrieveGuard(min_docs=3)
    return "generate" if guard.is_ok(state["docs"]) else "fallback"


def generate_node(state: GuardState) -> dict:
    return {"route": "generate"}


def fallback_node(state: GuardState) -> dict:
    return {"route": "fallback"}


graph = StateGraph(GuardState)
graph.add_node("router", lambda s: s)
graph.add_node("generate", generate_node)
graph.add_node("fallback", fallback_node)

graph.set_entry_point("router")
graph.add_conditional_edges("router", route_by_docs, {
    "generate": "generate",
    "fallback": "fallback",
})
graph.add_edge("generate", END)
graph.add_edge("fallback", END)

app = graph.compile()
```

### 예시 B: 점수 기반 전이 + 폴백

```python
"""
목적: 점수 기준으로 다음 노드를 선택한다.
설명: 점수가 낮으면 폴백 경로로 전환한다.
디자인 패턴: Policy
"""

from typing import TypedDict
from langgraph.graph import StateGraph, END


class ScoreState(TypedDict):
    score: float
    route: str


def route_by_score(state: ScoreState) -> str:
    return "fallback" if state["score"] < 0.6 else "generate"


def generate_node(state: ScoreState) -> dict:
    return {"route": "generate"}


def fallback_node(state: ScoreState) -> dict:
    return {"route": "fallback"}


graph = StateGraph(ScoreState)
graph.add_node("router", lambda s: s)
graph.add_node("generate", generate_node)
graph.add_node("fallback", fallback_node)

graph.set_entry_point("router")
graph.add_conditional_edges("router", route_by_score, {
    "generate": "generate",
    "fallback": "fallback",
})
graph.add_edge("generate", END)
graph.add_edge("fallback", END)

app = graph.compile()
```

### 예시 C: 에러 코드 포함 라우팅(폴백 연동)

```python
"""
목적: 전이 정책 결과에 에러 코드/사용자 메시지를 포함한다.
설명: 라우터 노드가 전이 결정을 내려 상태에 기록한다.
디자인 패턴: Policy
"""

from typing import TypedDict
from langgraph.graph import StateGraph, END


class FallbackState(TypedDict):
    failure_type: str
    score: float
    route: str
    error_code: str | None
    user_message: str | None


def router_node(state: FallbackState) -> dict:
    policy = TransitionWithFallbackPolicy()
    failure = FailureType(state["failure_type"])
    decision = policy.decide(GraphState.RETRIEVE, failure, state["score"])
    return {
        "route": decision.next_state.value,
        "error_code": decision.error_code.value if decision.error_code else None,
        "user_message": decision.user_message,
    }


def route_by_decision(state: FallbackState) -> str:
    return state["route"]


graph = StateGraph(FallbackState)
graph.add_node("router", router_node)
graph.add_node("generate", lambda s: s)
graph.add_node("fallback", lambda s: s)

graph.set_entry_point("router")
graph.add_conditional_edges("router", route_by_decision, {
    "generate": "generate",
    "fallback": "fallback",
})
graph.add_edge("generate", END)
graph.add_edge("fallback", END)

app = graph.compile()
```

---

## 11. 전이 로그/관측 설계

상태 전이는 **관측 가능성**이 있어야 운영이 안정됩니다.

```python
"""
목적: 상태 전이 로그를 표준 구조로 남긴다.
설명: 상태 흐름을 쉽게 추적할 수 있게 한다.
디자인 패턴: Event, Value Object
"""

from dataclasses import dataclass
from datetime import datetime


@dataclass(frozen=True)
class TransitionEvent:
    """상태 전이 이벤트를 기록한다."""

    from_state: str
    to_state: str
    reason: str
    timestamp: str


def build_event(from_state: str, to_state: str, reason: str) -> TransitionEvent:
    """전이 이벤트를 생성한다."""
    return TransitionEvent(
        from_state=from_state,
        to_state=to_state,
        reason=reason,
        timestamp=datetime.utcnow().isoformat(),
    )
```

---

## 12. 상태 전이 설계 시 안티패턴

- 전이 규칙이 코드 곳곳에 흩어져 있음
- 상태 이름이 모호해 디버깅이 어려움
- 전이 실패 시 폴백 경로가 없음
- 점수/비용/지연 신호 없이 라우팅을 고정

---

## 13. 구현 체크리스트

- 전이 규칙이 문서화되어 있는가?
- 전이표(Transition Table)가 존재하는가?
- 정책 객체가 단일 책임을 지키는가?
- 폴백 경로가 누락되지 않았는가?
- 에러 코드/사용자 메시지가 전이와 연동되는가?
- 상태 로그를 통해 흐름을 추적할 수 있는가?
- 점수/비용/지연 등 신호 기반 라우팅이 가능한가?
