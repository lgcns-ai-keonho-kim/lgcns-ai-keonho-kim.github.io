# 03. 병렬 프로그래밍 기초

## 이 챕터에서 배우는 것

- 병렬 실행의 목적과 기본 용어(팬아웃/팬인)
- 병렬 실행의 수준(그래프/노드/LLM 호출)
- 파이썬 병렬 처리 전략 선택 기준
- LangGraph 실전 병렬 예시
- 합류 조건(배리어)과 부분 실패 처리
- 병렬 실행 시 주의해야 할 위험 요소
- 합류(join) 전략의 종류와 사용 흐름

---

## 1. 병렬 실행이 필요한 이유

LLM 기반 파이프라인은 **서로 독립적인 작업**이 많습니다.
예: 요약 생성, 키워드 추출, 검증 질문 생성

이 작업들을 순차로 처리하면 지연이 커지고 사용자 경험이 나빠집니다.
병렬 실행은 **지연 시간을 줄이고 처리량을 높이는 핵심 전략**입니다.

---

## 2. 주니어를 위한 개념 정리

병렬을 제대로 쓰려면 **동시성 vs 병렬성**을 구분해야 합니다.

- **동시성(Concurrency)**: 여러 작업을 번갈아 처리(싱글 코어에서도 가능)
- **병렬성(Parallelism)**: 여러 작업을 동시에 처리(멀티 코어 필요)

또한 작업 특성에 따라 최적의 전략이 달라집니다.

- **I/O 바운드**: 네트워크/디스크 대기 시간이 긴 작업  
  → `asyncio`, `ThreadPoolExecutor`
- **CPU 바운드**: 계산이 무거운 작업  
  → `ProcessPoolExecutor`

LLM 호출은 대부분 **I/O 바운드**이므로 비동기/스레드 전략이 효과적입니다.

---

## 3. 병렬 실행의 수준(3계층)

병렬은 **어디에서 동시에 실행하느냐**에 따라 설계 방식이 달라집니다.

1) **그래프 수준 병렬**

- 서로 다른 노드를 동시에 실행
- 예: 검색/요약/검증 노드를 병렬 실행

1) **노드 수준 병렬**

- 하나의 노드 내부에서 작업을 동시에 수행
- 예: 문서 분할 요약을 병렬로 생성 후 합류

1) **LLM 호출 수준 병렬**

- 같은 노드 안에서 **여러 LLM 호출을 동시에 실행**
- 예: 프롬프트 변형, 앙상블, 검증 질문 생성

즉, “병렬은 노드 밖/안/호출 단계” 모두에서 가능합니다.

---

## 4. 병렬 실행의 기본 구조

- 팬아웃(Fan-out): 작업을 여러 갈래로 분기
- 팬인(Fan-in): 여러 결과를 하나로 합류

합류 지점에서 **충돌, 지연, 부분 실패**를 다뤄야 합니다.

---

## 5. 파이썬 병렬 처리 전략(상황별 선택)

파이썬은 **작업 특성(I/O 바운드 vs CPU 바운드)**에 따라 병렬 전략이 달라집니다.

- **I/O 바운드**: 네트워크/디스크 대기 시간이 긴 작업  
  → `asyncio` 또는 `ThreadPoolExecutor`
- **CPU 바운드**: 계산이 무거운 작업  
  → `ProcessPoolExecutor` (GIL 회피)
- **혼합형**: I/O 결과를 가공하는 작업  
  → `asyncio` + 필요 시 프로세스 분리

### 1) asyncio(비동기 I/O)

```python
"""
목적: I/O 바운드 작업을 비동기로 병렬 실행한다.
설명: asyncio.gather로 동시에 실행하고 실패를 포함해 수집한다.
디자인 패턴: Strategy
"""

import asyncio


async def run_io_tasks(coros: list[asyncio.Future]) -> list[object]:
    """비동기 작업을 병렬 실행한다."""
    return await asyncio.gather(*coros, return_exceptions=True)
```

### 2) ThreadPoolExecutor(블로킹 I/O)

```python
"""
목적: 블로킹 I/O 작업을 스레드로 병렬 실행한다.
설명: 네트워크/파일 호출이 블로킹일 때 사용한다.
디자인 패턴: Strategy
"""

from concurrent.futures import ThreadPoolExecutor
from collections.abc import Callable


def run_thread_tasks(tasks: list[Callable[[], object]]) -> list[object]:
    """스레드 기반 병렬 실행을 수행한다."""
    with ThreadPoolExecutor() as executor:
        futures = [executor.submit(task) for task in tasks]
        return [future.result() for future in futures]
```

### 3) ProcessPoolExecutor(CPU 바운드)

```python
"""
목적: CPU 바운드 작업을 프로세스로 병렬 실행한다.
설명: GIL을 피하고 실제 병렬 계산을 수행한다.
디자인 패턴: Strategy
"""

from concurrent.futures import ProcessPoolExecutor
from collections.abc import Callable


def run_process_tasks(tasks: list[Callable[[], object]]) -> list[object]:
    """프로세스 기반 병렬 실행을 수행한다."""
    with ProcessPoolExecutor() as executor:
        futures = [executor.submit(task) for task in tasks]
        return [future.result() for future in futures]
```

---

## 6. LangGraph 결합 포인트(실전 연결)

LangGraph는 **노드 자체를 병렬로 실행**할 수 있고,  
노드 내부에서도 `asyncio`로 **LLM 호출을 병렬화**할 수 있습니다.

### 1) 노드 내부 병렬(LLM 병렬 호출)

```python
"""
목적: 노드 내부에서 LLM 호출을 병렬로 실행한다.
설명: 동시성 제한과 타임아웃을 포함해 안정성을 높인다.
디자인 패턴: Policy
"""

import asyncio
from dataclasses import dataclass


@dataclass(frozen=True)
class ConcurrencyPolicy:
    """동시성 제한과 타임아웃 정책."""

    max_concurrency: int
    timeout_sec: float


async def bounded_gather(policy: ConcurrencyPolicy, coros: list[asyncio.Future]) -> list[object]:
    """동시성 제한을 적용한 병렬 실행."""
    semaphore = asyncio.Semaphore(policy.max_concurrency)

    async def _run(coro: asyncio.Future) -> object:
        async with semaphore:
            return await asyncio.wait_for(coro, timeout=policy.timeout_sec)

    return await asyncio.gather(*(_run(c) for c in coros), return_exceptions=True)


async def llm_parallel_node(state: dict) -> dict:
    """LLM 호출을 병렬로 수행하는 노드 예시."""
    coros = [
        call_llm_variant(state["input"], "v1"),
        call_llm_variant(state["input"], "v2"),
    ]
    results = await bounded_gather(ConcurrencyPolicy(2, 8.0), coros)
    return {"candidates": results}
```

### 2) 그래프 수준 병렬(팬아웃/팬인 연결)

```python
"""
목적: 팬아웃/팬인 구조를 그래프에 연결한다.
설명: 분기 노드에서 병렬 실행 후 병합 노드로 합류한다.
디자인 패턴: Pipeline
"""

from typing import TypedDict
from langgraph.graph import StateGraph, END


class FanoutState(TypedDict):
    input_text: str
    route_a: str
    route_b: str
    merged: str


async def route_a_node(state: FanoutState) -> dict:
    return {"route_a": await call_llm_variant(state["input_text"], "a")}


async def route_b_node(state: FanoutState) -> dict:
    return {"route_b": await call_llm_variant(state["input_text"], "b")}


def merge_node(state: FanoutState) -> dict:
    merged = merge_results(state["route_a"], state["route_b"])
    return {"merged": merged}


graph = StateGraph(FanoutState)
graph.add_node("fanout", lambda s: s)
graph.add_node("route_a", route_a_node)
graph.add_node("route_b", route_b_node)
graph.add_node("merge", merge_node)

graph.set_entry_point("fanout")
graph.add_edge("fanout", "route_a")
graph.add_edge("fanout", "route_b")
graph.add_edge("route_a", "merge")
graph.add_edge("route_b", "merge")
graph.add_edge("merge", END)
```

### 3) 결과 합류용 상태 설계

```python
"""
목적: 병렬 결과를 합류 노드에서 정리하기 위한 상태 구조.
설명: 성공/실패/메타데이터를 분리해 저장한다.
디자인 패턴: Value Object
"""

from dataclasses import dataclass


@dataclass(frozen=True)
class ParallelState:
    """병렬 결과를 모아두는 상태."""

    results: dict[str, object]
    errors: list[str]
```

---

## 7. 합류 조건(배리어/검증)과 부분 실패 처리

팬인 노드에서는 **모든 결과가 준비됐는지 확인(배리어)**하고,  
**부분 실패를 허용할지 결정**하는 로직이 필요합니다.

### 1) 배리어(Barrier) 검사 예시

```python
"""
목적: 모든 병렬 결과가 준비됐는지 검사한다.
설명: 누락된 결과가 있으면 합류를 지연한다.
디자인 패턴: Guard
"""

from dataclasses import dataclass


@dataclass(frozen=True)
class BarrierPolicy:
    """필수 결과 키가 모두 있는지 검사한다."""

    required_keys: set[str]

    def is_ready(self, results: dict[str, object]) -> bool:
        """필수 키가 모두 존재하는지 확인한다."""
        return self.required_keys.issubset(results.keys())
```

### 2) 부분 실패 허용 정책 예시

```python
"""
목적: 부분 실패를 허용할지 정책으로 결정한다.
설명: 실패 개수가 임계치를 넘으면 합류를 중단한다.
디자인 패턴: Policy
"""

from dataclasses import dataclass


@dataclass(frozen=True)
class PartialFailurePolicy:
    """부분 실패 허용 기준을 정의한다."""

    max_failures: int

    def is_acceptable(self, errors: list[str]) -> bool:
        """허용 가능한 실패 개수인지 확인한다."""
        return len(errors) <= self.max_failures
```

---

## 8. LangGraph 실전 예시

아래는 **실제 서비스에서 자주 쓰는 병렬 패턴**을 LangGraph 관점으로 정리한 예시입니다.

### 예시 A: 다중 리트리벌 병렬 + 리랭크 + 답변

```python
"""
목적: 여러 인덱스를 병렬 검색한 뒤 리랭크해서 답변을 생성한다.
설명: 팬아웃(검색) → 팬인(리랭크) → 응답 생성 흐름을 구성한다.
디자인 패턴: Pipeline, Reducer
"""

from typing import TypedDict
from langgraph.graph import StateGraph, END


class RAGState(TypedDict):
    query: str
    docs_a: list[str]
    docs_b: list[str]
    merged_docs: list[str]
    answer: str


async def search_index_a(state: RAGState) -> dict:
    return {"docs_a": await search_a(state["query"])}


async def search_index_b(state: RAGState) -> dict:
    return {"docs_b": await search_b(state["query"])}


def merge_docs(state: RAGState) -> dict:
    merged = rerank(state["docs_a"] + state["docs_b"])
    return {"merged_docs": merged}


async def generate_answer(state: RAGState) -> dict:
    answer = await call_llm_with_context(state["query"], state["merged_docs"])
    return {"answer": answer}


graph = StateGraph(RAGState)
graph.add_node("fanout", lambda s: s)
graph.add_node("search_a", search_index_a)
graph.add_node("search_b", search_index_b)
graph.add_node("merge", merge_docs)
graph.add_node("answer", generate_answer)

graph.set_entry_point("fanout")
graph.add_edge("fanout", "search_a")
graph.add_edge("fanout", "search_b")
graph.add_edge("search_a", "merge")
graph.add_edge("search_b", "merge")
graph.add_edge("merge", "answer")
graph.add_edge("answer", END)
```

실전에서는 `merge` 단계에서 **배리어 검사**와 **부분 실패 허용 기준**을 먼저 적용한 뒤  
합류/대체 경로를 결정하는 것이 안전합니다.

### 예시 B: 노드 내부 LLM 병렬 (프롬프트 변형 + 선택)

```python
"""
목적: 한 노드에서 여러 LLM 호출을 병렬로 실행한다.
설명: 후보 답변을 생성한 뒤 가장 안전/정확한 답을 선택한다.
디자인 패턴: Policy, Strategy
"""

import asyncio
from langgraph.graph import StateGraph, END
from typing import TypedDict


class AnswerState(TypedDict):
    question: str
    candidates: list[str]
    answer: str


async def generate_candidates(state: AnswerState) -> dict:
    coros = [
        call_llm_variant(state["question"], "concise"),
        call_llm_variant(state["question"], "detailed"),
        call_llm_variant(state["question"], "safe"),
    ]
    results = await asyncio.gather(*coros, return_exceptions=True)
    candidates = [r for r in results if isinstance(r, str)]
    return {"candidates": candidates}


def select_best(state: AnswerState) -> dict:
    best = choose_best_candidate(state["candidates"])
    return {"answer": best}


graph = StateGraph(AnswerState)
graph.add_node("generate_candidates", generate_candidates)
graph.add_node("select_best", select_best)
graph.set_entry_point("generate_candidates")
graph.add_edge("generate_candidates", "select_best")
graph.add_edge("select_best", END)
```

---

## 9. 병렬 실행 시 주의해야 할 위험 요소

- **비용 폭주**: 병렬 호출 수 증가로 비용이 급증
- **레이트 리밋**: API 제한으로 일부 작업 실패
- **비결정성**: 실행 순서/결과 순서가 바뀜
- **부분 실패 전파**: 일부 실패가 전체 합류를 막음
- **타임아웃 합류**: 느린 작업이 전체 지연을 유발
- **데이터 경합**: 공유 상태를 동시에 수정하는 문제

병렬은 성능을 올리지만, **운영 리스크도 함께 늘어납니다**.

---

## 10. LLM 병렬 호출 대표 상황

- **프롬프트 변형**: 서로 다른 지시문으로 여러 답 생성
- **앙상블**: 여러 모델/샘플 결과를 비교해 최종 선택
- **검증 병렬화**: 생성과 검증 질문을 동시에 생성
- **도구 병렬화**: 검색/계산/정책 검사를 동시에 실행

LLM 병렬 호출은 **품질을 높이지만 비용과 지연이 늘어날 수 있습니다**.

---

## 11. 합류 전략의 종류

- 우선순위 합류: 가장 신뢰도 높은 결과만 선택
- 다중 결과 합류: 여러 결과를 병합(리듀서 패턴)
- 부분 성공 허용: 일부 실패해도 나머지 결과로 진행
- 쿼럼 합류: 일정 개수 이상 성공하면 합류
- 타임아웃 합류: 특정 시간 이후 결과만 합류

---

## 12. 병렬 계획 예시(개념 코드)

아래 코드는 병렬 작업 목록을 정의하는 간단한 구조입니다.

```python
"""
목적: 병렬로 실행할 작업 목록을 정의한다.
설명: 작업의 이름과 입력을 캡슐화한다.
디자인 패턴: Command
"""

from dataclasses import dataclass


@dataclass(frozen=True)
class ParallelTask:
    """병렬로 실행할 단일 작업을 정의한다."""

    name: str
    payload: str


@dataclass(frozen=True)
class ParallelPlan:
    """병렬 작업 묶음을 표현한다."""

    tasks: list[ParallelTask]

    def describe(self) -> list[str]:
        """작업 요약을 반환한다.

        Returns:
            list[str]: 작업 설명 문자열 목록.
        """
        return [f"{task.name}: {task.payload}" for task in self.tasks]
```

---

## 13. 사용 흐름 예시(개념)

병렬 계획을 만들고, 결과를 합류 전략으로 정리하는 흐름입니다.

```python
"""
목적: 병렬 계획과 합류 전략을 함께 사용한다.
설명: 병렬 실행 결과를 정책에 따라 정리한다.
디자인 패턴: Command, Policy
"""

from dataclasses import dataclass


@dataclass(frozen=True)
class QuorumJoinPolicy:
    """일정 개수 이상 성공하면 합류한다."""

    quorum: int

    def join(self, results: dict[str, str]) -> dict[str, str]:
        """쿼럼 기준으로 결과를 필터링한다."""
        if len(results) >= self.quorum:
            return results
        return {}


def parallel_flow_example(plan: ParallelPlan, results: dict[str, str]) -> dict[str, str]:
    """병렬 계획 결과를 합류 정책으로 정리한다."""
    _ = plan.describe()
    return QuorumJoinPolicy(quorum=2).join(results)
```

---

## 14. 구현 체크리스트

- 병렬로 처리해도 상호 의존성이 없는가?
- 합류 전략이 명확히 정의되어 있는가?
- 부분 실패 시 사용자에게 전달할 정책이 있는가?
- 병렬 실행 비용이 예산 범위를 넘지 않는가?
- 노드 내부 병렬(LLM 다중 호출)까지 고려했는가?
- 작업 특성(I/O/CPU)에 맞는 파이썬 병렬 전략을 선택했는가?
- 합류 전에 배리어/검증 로직이 정의되어 있는가?
- 부분 실패를 허용하는 기준이 명확한가?
