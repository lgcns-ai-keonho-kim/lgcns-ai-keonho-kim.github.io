# 01. 폴백 패턴 개요

## 이 챕터에서 배우는 것

- LangGraph 기반 그래프에서 폴백이 발생하는 대표 상황
- 폴백 설계의 3계층(노드/경로/그래프) 관점
- 폴백 정책을 체계화하는 설계 원칙과 산출물

---

## 1. LangGraph에서 폴백이 발생하는 대표 상황

그래프를 설계할 때 폴백은 **실패의 종류와 위치**에 따라 발생합니다.
아래 상황은 실제 서비스에서 가장 자주 만나는 폴백 트리거입니다.

- **노드 실행 실패**: LLM 호출 오류, 툴 호출 실패, 외부 API 장애
- **출력 검증 실패**: JSON 스키마/포맷 불일치, 금지어 포함, 길이 초과, **Pydantic 검증 실패**
- **검색/리트리벌 실패**: 검색 결과 없음, 점수 기준 미달, 인덱스 불일치
- **라우팅 조건 미충족**: Guard 조건 실패로 다음 경로 결정 불가
- **시간/비용 초과**: 타임아웃, 토큰 예산 초과
- **안전성 정책 위반**: 민감 정보 노출 위험, 정책 기반 차단
- **병렬 합류 실패**: 일부 노드 실패, 결과 품질 불균형

핵심은 “실패를 숨기지 않고 **미리 분류하고 대응**하는 것”입니다.

---

## 2. 폴백 설계의 3계층 관점

폴백은 어디에서 발생하느냐에 따라 성격이 달라집니다.

### 1) 노드 수준 폴백

- 한 노드 내부에서 실패를 감지하고 **축소된 결과**를 반환
- 예: 고급 요약 실패 → 간단 요약 제공

### 2) 경로 수준 폴백

- 라우팅 규칙에 따라 **대체 경로로 분기**
- 예: 고정밀 경로 실패 → 저비용 경로로 전환

### 3) 그래프 수준 폴백

- 그래프 전체 결과가 불완전할 때 **서비스 레벨 응답**으로 보정
- 예: “부분 결과만 제공합니다” 같은 전역 메시지

이 3계층을 구분하면 폴백의 책임이 명확해지고 운영이 쉬워집니다.

---

## 3. 폴백 설계 원칙

초보자가 가장 많이 실패하는 부분은 **폴백을 예외 처리로만 생각하는 것**입니다.
폴백은 설계의 일부로 문서화되어야 합니다.

- **예측 가능성**: 동일 실패에 동일 결과를 반환
- **최소 품질 보장**: 사용자가 이해 가능한 결과는 반드시 제공
- **비용 상한**: 폴백 경로가 비용 폭주를 만들지 않도록 제한
- **관찰 가능성**: 폴백 발생 이유와 경로가 로그로 남아야 함
- **부분 성공 허용**: 100% 실패가 아니라면 가능한 결과를 유지

---

## 4. 폴백 설계를 위한 핵심 산출물

폴백은 구현보다 **문서화된 기준**이 먼저입니다.

- 실패 유형 분류표(모델/툴/검증/라우팅/시간/비용)
- 폴백 경로 전이표(정상 → 실패 → 대체 경로)
- 사용자 메시지 템플릿(투명성 + 최소 불안 유발)
- 운영 지표 정의(폴백 비율, 폴백 유형 비중, 복구 성공률)

---

## 5. 에러 코드/사용자 메시지 관리(ENUM 중심)

용어 기준은 아래와 같이 통일합니다.

- **실패 유형**: 실패의 원인 분류(모델/툴/검증/라우팅/타임아웃 등)
- **에러 코드**: 실패 유형을 시스템이 다루는 식별자(Enum)
- **사용자 메시지**: 화면에 노출되는 문구(톤/불안 조절)

실패가 발생했을 때 **같은 실패 유형이 항상 동일한 에러 코드/사용자 메시지로 연결**되도록 만드는 것이 중요합니다.
이를 위해 **Enum 하나에 에러 코드 + 사용자 메시지를 함께 정의**하면 운영과 로깅이 훨씬 쉬워집니다.

- 에러 코드가 있으면 **로그/지표/알림**이 일관됨
- 사용자 메시지는 코드와 분리되어 **톤 조절**이 쉬움
- 정책/문서/테스트에서 **의미가 명확**해짐

```python
"""
목적: 실패 유형을 에러 코드와 사용자 메시지로 일관되게 관리한다.
설명: Enum을 기준으로 사용자 메시지를 중앙화한다.
디자인 패턴: Value Object
"""

from enum import Enum


class ErrorCode(Enum):
    """운영과 사용자 메시지를 연결하는 에러 코드."""

    VALIDATION = ("validation_error", "출력 형식 오류가 발생했습니다. 간단 요약으로 안내합니다.")
    TOOL = ("tool_error", "외부 도구 호출에 실패했습니다. 기본 안내만 제공합니다.")
    TIMEOUT = ("timeout", "처리가 지연되었습니다. 잠시 후 다시 시도해 주세요.")
    RETRIEVAL_EMPTY = ("retrieval_empty", "관련 정보를 찾지 못했습니다. 일반 설명을 제공합니다.")
    UNKNOWN = ("unknown_error", "처리 중 문제가 발생했습니다. 잠시 후 다시 시도해 주세요.")

    @property
    def code(self) -> str:
        """에러 코드 문자열을 반환한다."""
        return self.value[0]

    @property
    def user_message(self) -> str:
        """사용자 메시지를 반환한다."""
        return self.value[1]
```

### 사용 흐름 예시(개념)

실패 유형을 **에러 코드로 매핑**한 뒤, 사용자 메시지를 조회해 응답에 반영합니다.

```python
"""
목적: 실패 유형 → 에러 코드 → 사용자 메시지로 이어지는 흐름을 보여준다.
설명: Enum에서 사용자 메시지를 꺼내 응답에 포함한다.
디자인 패턴: Value Object
"""

from dataclasses import dataclass


@dataclass(frozen=True)
class FailureMapper:
    """실패 유형을 에러 코드로 변환한다."""

    def to_error_code(self, failure_type: FailureType) -> ErrorCode:
        """실패 유형을 에러 코드로 매핑한다."""
        table = {
            FailureType.VALIDATION_ERROR: ErrorCode.VALIDATION,
            FailureType.TOOL_ERROR: ErrorCode.TOOL,
            FailureType.RETRIEVAL_EMPTY: ErrorCode.RETRIEVAL_EMPTY,
            FailureType.TIMEOUT: ErrorCode.TIMEOUT,
        }
        return table.get(failure_type, ErrorCode.UNKNOWN)


def build_user_response(failure_type: FailureType) -> dict:
    """에러 코드와 사용자 메시지를 포함한 응답을 만든다."""
    error_code = FailureMapper().to_error_code(failure_type)
    return {
        "status": "fallback",
        "error_code": error_code.code,
        "user_message": error_code.user_message,
    }
```

---

## 6. 폴백 정책 구조 예시(개념 코드)

아래 코드는 **폴백 정책을 데이터 구조로 분리**하는 예시입니다.
디자인 패턴 관점에서는 **Strategy + Policy** 조합으로 이해하면 쉽습니다.

```python
"""
목적: 실패 유형별 사용자 메시지와 경로를 분리해 관리한다.
설명: 실패 분류와 사용자 응답 정책을 명시적으로 정의한다.
디자인 패턴: Strategy, Policy
"""

from dataclasses import dataclass
from enum import Enum


class FailureType(Enum):
    """실패 유형을 명확히 구분한다."""

    MODEL_ERROR = "model_error"
    TOOL_ERROR = "tool_error"
    VALIDATION_ERROR = "validation_error"
    RETRIEVAL_EMPTY = "retrieval_empty"
    TIMEOUT = "timeout"


@dataclass(frozen=True)
class FallbackDecision:
    """사용자 메시지와 경로를 함께 정의한다."""

    message: str
    next_route: str


@dataclass(frozen=True)
class FallbackPolicy:
    """실패 유형에 따른 폴백 결정을 제공한다."""

    def decide(self, failure_type: FailureType) -> FallbackDecision:
        """실패 유형에 맞는 폴백 결정을 반환한다.

        Args:
            failure_type: 발생한 실패 유형.

        Returns:
            FallbackDecision: 메시지와 다음 경로 정보.
        """
        if failure_type == FailureType.RETRIEVAL_EMPTY:
            return FallbackDecision(
                message="관련 정보를 찾지 못했습니다. 일반 설명을 제공합니다.",
                next_route="general_answer",
            )
        if failure_type == FailureType.VALIDATION_ERROR:
            return FallbackDecision(
                message="출력 형식 오류가 발생했습니다. 요약형으로 다시 안내합니다.",
                next_route="safe_summary",
            )
        if failure_type == FailureType.TOOL_ERROR:
            return FallbackDecision(
                message="외부 도구 호출에 실패했습니다. 기본 안내만 제공합니다.",
                next_route="safe_default",
            )
        return FallbackDecision(
            message="처리 중 문제가 발생했습니다. 잠시 후 다시 시도해 주세요.",
            next_route="end",
        )
```

---

## 7. 디자인 패턴 관점 요약

- **Strategy/Policy**: 실패 유형별 대응 전략 분리
- **Chain of Responsibility**: 여러 폴백 단계를 순차적으로 적용
- **State**: 상태 전이에 따라 폴백 경로 결정
- **Circuit Breaker**: 반복 실패 시 특정 경로 차단
- **Bulkhead**: 실패를 격리해 전체 그래프 영향을 줄임

---

## 8. 구현 체크리스트

- 실패 유형이 명확히 분류되어 있는가?
- 에러 코드와 사용자 메시지가 Enum 중심으로 관리되는가?
- 폴백 경로가 문서화되어 있는가?
- 사용자 메시지가 과도하게 불안을 주지 않는가?
- 폴백 발생 이유가 로그/메트릭으로 남는가?
- 폴백 경로가 비용/시간 상한을 지키는가?
