# 03. 인메모리 체크포인터

## 이 챕터에서 배우는 것

- 인메모리 체크포인터의 장단점
- 키/버전 설계와 저장 구조
- 간단한 구현 흐름(개념)
- 운영 시 주의사항

---

## 1. 인메모리 체크포인터의 특징

인메모리 체크포인터는 **구현이 단순하고 빠르지만**
프로세스 재시작 시 데이터가 사라집니다.

- **장점**: 빠른 저장/복구, 구현 간단
- **단점**: 프로세스 종료 시 데이터 유실

---

## 2. 키/버전 설계

인메모리에서도 **버전 관리**가 필요합니다.

- `thread_id`: 세션 식별자
- `checkpoint_id`: 버전 식별자
- `state`: 상태 스냅샷
- `metadata`: 노드/라우팅/시간 정보

---

## 3. 인메모리 체크포인터 구현(개념)

```python
"""
목적: 인메모리 체크포인터를 간단히 구현한다.
설명: 딕셔너리에 상태를 누적 저장한다.
디자인 패턴: Repository
"""

class InMemoryCheckpointer:
    def __init__(self) -> None:
        self._store = {}
        self._version = {}

    def save(self, thread_id: str, state: dict, metadata: dict) -> str:
        version = self._version.get(thread_id, 0) + 1
        self._version[thread_id] = version
        checkpoint_id = f"ckpt-{version:04d}"
        self._store.setdefault(thread_id, {})[checkpoint_id] = {
            "state": state,
            "metadata": metadata,
        }
        return checkpoint_id

    def load(self, thread_id: str, checkpoint_id: str | None = None) -> dict | None:
        if thread_id not in self._store:
            return None
        if checkpoint_id is None:
            checkpoint_id = f"ckpt-{self._version[thread_id]:04d}"
        return self._store[thread_id].get(checkpoint_id)
```

---

## 4. 운영 시 주의사항

- **정리 정책**: 메모리 폭주 방지(최신 N개 유지)
- **동시성 주의**: 멀티 스레드 환경에서는 락 필요
- **장애 복구 한계**: 프로세스 재시작 시 복구 불가

---

## 5. 구현 체크리스트

- thread_id와 checkpoint_id가 일관적인가?
- 최신 버전 조회가 가능한가?
- 정리 정책이 존재하는가?
- 동시성 문제가 없는가?
