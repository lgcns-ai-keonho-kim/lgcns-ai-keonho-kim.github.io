# 01. 체크포인터 개요

## 이 챕터에서 배우는 것

- 체크포인터가 필요한 이유와 사용 시점
- 저장/복구 흐름의 기본 개념
- 체크포인터 설계 원칙과 운영 기준
- 동기 vs 비동기 체크포인터 차이
- 실전 시나리오에서의 활용 방법

---

## 1. 체크포인터가 필요한 이유

LangGraph 그래프는 **여러 노드가 연속으로 실행되는 장기 작업**입니다.
중간에 장애가 발생하면 **처음부터 재실행**해야 하고, 이는 비용과 시간을 크게 증가시킵니다.

체크포인터는 아래 문제를 해결합니다.

- **재시작 비용 감소**: 중간 상태에서 재개
- **네트워크 단절 복구**: 클라이언트 재접속 시 이어서 실행
- **장시간 작업 안정화**: 워커 재시작에도 진행 상태 유지
- **운영 관측성 강화**: 실행 흐름을 기록해 분석 가능

---

## 2. 체크포인터 핵심 개념

- **State 스냅샷**: 특정 시점의 그래프 상태
- **thread_id**: 세션/대화 단위 식별자
- **checkpoint_id**: 상태 버전 식별자
- **메타데이터**: 저장 시각, 노드 이름, 라우팅 정보

체크포인터는 **State를 버전으로 관리하는 저장소**라고 이해하면 쉽습니다.

---

## 3. 저장/복구 흐름(개념)

```python
"""
목적: 체크포인트 저장/복구 흐름을 설명한다.
설명: 상태를 저장하고 필요한 시점에 다시 불러온다(예시 포함).
디자인 패턴: Memento
"""

from dataclasses import dataclass
from typing import Any, Dict, Optional


@dataclass(frozen=True)
class Checkpoint:
    """체크포인트 스냅샷."""

    thread_id: str
    checkpoint_id: str
    state: Dict[str, Any]
    metadata: Dict[str, Any]


class Checkpointer:
    """체크포인터 인터페이스(개념)."""

    def save(self, thread_id: str, state: Dict[str, Any], metadata: Dict[str, Any]) -> str:
        """상태와 메타데이터를 저장하고 checkpoint_id를 반환한다."""
        raise NotImplementedError

    def load(self, thread_id: str, checkpoint_id: str) -> Optional[Checkpoint]:
        """특정 checkpoint_id를 복구한다."""
        raise NotImplementedError


# 저장 흐름(개념 예시)
def save_flow(checkpointer: Checkpointer, thread_id: str) -> str:
    # 1) 노드 실행 후 상태 업데이트
    state = {"messages": [{"role": "user", "content": "요약해줘"}], "turn_count": 1}
    # 2) 메타데이터 구성(노드/라우팅/시간 등)
    metadata = {"node": "answer", "route": "generate", "reason": "normal"}
    # 3) 체크포인트 저장
    checkpoint_id = checkpointer.save(thread_id=thread_id, state=state, metadata=metadata)
    return checkpoint_id


# 복구 흐름(개념 예시)
def restore_flow(checkpointer: Checkpointer, thread_id: str, checkpoint_id: str) -> Dict[str, Any]:
    # 1) checkpoint_id로 복구
    checkpoint = checkpointer.load(thread_id=thread_id, checkpoint_id=checkpoint_id)
    if checkpoint is None:
        return {"messages": [], "turn_count": 0}
    # 2) 복구된 state로 그래프 재개
    return checkpoint.state
```

---

## 4. 설계 원칙

- **최소 저장**: 꼭 필요한 상태만 저장
- **일관성 보장**: 저장 시점의 상태는 깨지지 않아야 함
- **버전 관리**: checkpoint_id로 이력 추적
- **정리 정책**: 오래된 체크포인트 제거

---

## 5. 동기 vs 비동기 체크포인터 차이

동기/비동기 체크포인터의 차이는 **정합성보다 성능/지연**에 영향을 줍니다.

### 동기 체크포인터

- **장점**: 구현이 단순, 디버깅이 쉬움
- **단점**: 저장/복구 시 I/O 대기 발생
- **적합한 경우**: PoC, 낮은 동시성, 단일 워커

### 비동기 체크포인터

- **장점**: 저장 I/O가 병목이 되지 않음
- **단점**: 구현 복잡도 증가, 운영/관측 부담 증가
- **적합한 경우**: 고동시성, 대규모 트래픽

주의할 점

- 대화 꼬임/섞임 문제는 **체크포인터가 동기냐 비동기냐보다**
  **thread_id 관리와 동시성 제어**가 더 큰 원인입니다.

프로젝트 예시에서는 **비동기 Redis 체크포인터 구현체**를 제공합니다.

---

## 6. 실전 시나리오

### 시나리오 A: 사용자 재접속

- 작업 도중 연결이 끊김
- 동일 thread_id로 재연결 후 마지막 체크포인트에서 재개

### 시나리오 B: 워커 장애

- 워커가 중간에 종료됨
- 새 워커가 마지막 체크포인트 로드 후 계속 실행

### 시나리오 C: 품질 분석

- 여러 checkpoint_id를 비교해 결과 품질 분석

---

## 7. 구현 체크리스트

- 체크포인트 저장 시점이 정의되어 있는가?
- thread_id와 checkpoint_id가 명확한가?
- 상태 스냅샷과 메타데이터가 분리되어 있는가?
- 정리 정책(TTL/버전 제한)이 존재하는가?
- 복구 시나리오가 문서화되어 있는가?
