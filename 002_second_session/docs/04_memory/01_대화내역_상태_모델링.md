# 01. 대화내역 상태 모델링

## 이 챕터에서 배우는 것

- LangGraph 상태(State)로 대화내역을 모델링하는 이유
- 대화내역 스키마의 필수 필드와 분리 기준
- 불변/가변 데이터 분리 방식
- 리듀서(누적 함수) 기반의 상태 업데이트 원리
- 초급→중급→고급 튜토리얼 흐름
- 실무에서 발생하는 상태 관리 리스크와 대응

---

## 1. 왜 대화내역을 상태로 모델링해야 하는가

LangGraph는 그래프 실행 과정에서 **상태를 누적**합니다.
대화내역을 상태로 두면 다음 장점이 있습니다.

- **일관성**: 모든 노드가 동일한 상태를 기준으로 동작
- **복구성**: 체크포인터와 결합해 중단 시점 복구 가능
- **관찰성**: 상태가 남아 로그/메트릭 분석에 유리
- **정책 적용**: 요약/트리밍/라우팅 정책을 상태에 반영 가능

즉, 대화내역은 단순한 리스트가 아니라 **서비스 운영을 위한 핵심 상태**입니다.

---

## 2. 상태 스키마의 핵심 구성 요소

대화내역 중심 상태는 보통 아래 필드로 구성합니다.

- `history`: 메시지 목록(append-only 권장)
- `summary`: 요약 문자열(선택)
- `turn_count`: 누적 턴 수
- `last_user_message`: 마지막 사용자 입력
- `last_assistant_message`: 마지막 모델 응답
- `route`: 라우팅 결과
- `error_code`: 실패 유형(폴백 기준)
- `trace_id`: 요청 추적 ID

이 중 **history와 summary는 분리**해야 합니다.
요약은 파생 데이터이므로 **원본 메시지는 보존**하는 것이 원칙입니다.

---

## 3. 불변/가변 데이터 분리 원칙

- **불변 데이터**: 사용자 입력, 모델 출력, 시스템 메시지
- **가변 데이터**: 요약, 라우팅 점수, 캐시, 임시 메타데이터

불변 데이터를 수정하면 **감사 추적과 재현**이 어려워집니다.
따라서 원본 메시지는 유지하고, 요약/정제는 별도 필드로 다룹니다.

---

## 4. LangGraph 리듀서(누적 함수) 이해하기

LangGraph는 `Annotated`로 리듀서를 등록해 **누적 정책을 분리**합니다.
아래는 `history`와 `turn_count`를 누적하는 대표 예시입니다.

```python
"""
목적: 상태 누적 방식을 리듀서로 분리한다.
설명: history는 append-only, turn_count는 증가분만 반영한다.
디자인 패턴: 상태 패턴
"""

from typing import Annotated, TypedDict


def add_history(existing: list[dict], incoming: list[dict] | None) -> list[dict]:
    """대화 내역을 누적한다."""
    if incoming is None:
        return existing
    return existing + incoming


def add_turn(existing: int, incoming: int | None) -> int:
    """턴 수를 누적한다."""
    if incoming is None:
        return existing
    return existing + incoming


class ChatState(TypedDict):
    """대화 그래프 상태 스키마."""

    history: Annotated[list[dict], add_history]
    turn_count: Annotated[int, add_turn]
    summary: str | None
```

이 구조를 사용하면 노드에서는 **증가분만 반환**해도 됩니다.

---

## 5. 초급 튜토리얼: 최소 상태 스키마 만들기

### 목표

- `history`, `turn_count` 중심의 최소 상태를 만든다.

### 단계

1) 상태 필드 확정
2) 리듀서 작성
3) 그래프에 상태 타입 연결

```python
"""
목적: 초급용 최소 상태 스키마를 정의한다.
설명: 대화내역과 턴 수만 관리한다.
디자인 패턴: 상태 패턴
"""

from typing import Annotated, TypedDict


def add_history(existing: list[dict], incoming: list[dict] | None) -> list[dict]:
    """대화 내역을 누적한다."""
    return existing + (incoming or [])


def add_turn(existing: int, incoming: int | None) -> int:
    """턴 수를 누적한다."""
    return existing + (incoming or 0)


class SimpleChatState(TypedDict):
    """최소 상태 스키마."""

    history: Annotated[list[dict], add_history]
    turn_count: Annotated[int, add_turn]
```

---

## 6. 중급 튜토리얼: history에 스키마 검증 추가

### 목표

- `history` 항목을 Pydantic으로 검증한다.
- append 노드가 **증가분만 반환**하도록 구성한다.

```python
"""
목적: history에 저장될 항목을 검증해 일관성을 유지한다.
설명: Pydantic 모델을 이용해 role/content를 보장한다.
디자인 패턴: DTO
"""

from pydantic import BaseModel


class ChatHistoryItem(BaseModel):
    """대화 내역 항목."""

    role: str
    content: str
    created_at: str | None = None
```

```python
"""
목적: 신규 메시지 2개만 반환해 리듀서가 누적하도록 한다.
설명: 사용자/어시스턴트 메시지를 검증 후 반환한다.
디자인 패턴: 커맨드
"""

from secondsession.core.chat.state.chat_state import ChatState
from secondsession.core.chat.const.chat_history_item import ChatHistoryItem


def append_history_node(state: ChatState) -> dict:
    """대화 내역을 갱신한다."""
    user = ChatHistoryItem(role="user", content=state["last_user_message"]).model_dump()
    assistant = ChatHistoryItem(role="assistant", content=state["last_assistant_message"] or "").model_dump()
    return {
        "history": [user, assistant],
        "turn_count": 1,
    }
```

---

## 7. 고급 튜토리얼: 상태 확장과 추적성 강화

### 목표

- trace_id, route, error_code를 상태에 포함한다.
- 상태 변화가 **운영 메트릭**으로 연결되도록 설계한다.

```python
"""
목적: 상태 메타데이터를 함께 보관한다.
설명: 추적/라우팅/폴백 정보를 상태에 넣어 관찰성을 높인다.
디자인 패턴: 상태 패턴
"""

from typing import TypedDict


class ChatMetaState(TypedDict):
    """메타데이터 확장 상태."""

    trace_id: str
    route: str | None
    error_code: str | None
```

운영에서는 `trace_id`를 로그/스트리밍 이벤트에도 동일하게 포함해야 합니다.

---

## 8. 실무 고려사항

- **중복 방지**: 동일 요청이 재시도될 경우 중복 메시지가 쌓이지 않게 한다.
- **메시지 순서 보장**: 비동기 실행에서는 `seq`나 `created_at`으로 순서를 보강한다.
- **메모리 폭주 방지**: history 무한 누적을 방지하기 위한 트리밍/요약 정책 필요
- **데이터 보존 정책**: 보관 기간과 삭제 기준을 문서화한다.
- **품질 회귀 대응**: 요약/트리밍이 품질을 떨어뜨릴 때 롤백 전략을 둔다.

---

## 9. 구현 체크리스트

- 상태 스키마가 문서화되어 있는가?
- history는 append-only로 유지되는가?
- 요약/캐시 등 파생 데이터가 분리되어 있는가?
- 리듀서가 증가분만 처리하도록 설계되었는가?
- trace_id/route/error_code가 관찰 가능하게 남는가?
