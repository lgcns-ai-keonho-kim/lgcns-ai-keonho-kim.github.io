# 05. 외부 저장소 연동 전략

## 이 챕터에서 배우는 것

- 외부 저장소가 필요한 이유와 선택 기준
- 저장 키 설계와 읽기/쓰기 경로 분리
- 리포지토리 패턴으로 저장소 접근 캡슐화
- 초급→중급→고급 튜토리얼 흐름
- 실무에서 반드시 고려해야 할 성능/운영 이슈

---

## 1. 왜 외부 저장소가 필요한가

메모리에만 두면 다음 문제가 발생합니다.

- 서버 재시작 시 히스토리 유실
- 멀티 인스턴스 환경에서 상태 공유 불가
- 장기 대화 기록 보관 불가

따라서 **Redis/DB/파일 스토리지**와 연동해
히스토리를 외부에 저장하는 것이 기본입니다.

---

## 2. 저장소 선택 기준

- **지연 허용치**: 실시간 응답이 필요한가?
- **데이터 크기**: 장기 보관/대량 저장이 필요한가?
- **조회 패턴**: 최근 대화 중심인지, 특정 세션 재조회인지
- **운영 비용**: 관리/백업/스케일 비용

일반적인 시작점은 **Redis(캐시) + DB(장기 보관)** 조합입니다.

---

## 3. 키 설계와 경로 분리

### 키 설계 원칙

- `session_id` + `thread_id`를 기본 키로 사용
- 다중 채널이면 `channel`을 키에 포함

### 경로 분리

- **쓰기 경로**: 요청 처리 중 빠르게 저장
- **읽기 경로**: 스트리밍/재요청 시 조회

이 구조가 **확장성과 장애 복원력**을 높입니다.

---

## 4. 초급 튜토리얼: Redis 리스트에 저장

```python
"""
목적: 대화내역을 Redis 리스트에 저장한다.
설명: session_id/thread_id 기반 키를 구성한다.
디자인 패턴: 리포지토리
"""


def build_history_key(session_id: str, thread_id: str) -> str:
    """세션/스레드 기반 저장 키를 만든다."""
    return f"chat:history:{session_id}:{thread_id}"
```

```python
"""
목적: history 항목을 Redis에 저장한다.
설명: rpush로 append-only 리스트를 만든다.
디자인 패턴: 리포지토리
"""

import json


def save_history_item(redis_client, key: str, item: dict) -> None:
    """대화 항목을 저장한다."""
    payload = json.dumps(item, ensure_ascii=False)
    redis_client.rpush(key, payload)
```

---

## 5. 중급 튜토리얼: 읽기/쓰기 경로 분리

실무에서는 **쓰기 경로**와 **읽기 경로**를 분리합니다.

- 요청 처리: rpush로 빠르게 누적
- 스트리밍: lrange로 일정 구간 조회
- 재연결: last_index 이후만 읽기

이 구조는 **대규모 트래픽**에서 매우 안정적입니다.

---

## 6. 고급 튜토리얼: 장기 보관/아카이빙

장기 보관은 Redis만으로 부족합니다.
따라서 **DB/오브젝트 스토리지**에 아카이빙합니다.

- Redis: 최근 대화(빠른 접근)
- DB: 장기 보관 및 분석
- 배치 작업: 오래된 대화를 이동/압축

```python
"""
목적: 아카이빙 대상 여부를 판별한다.
설명: 메시지 수/기간 기준으로 이동 대상을 결정한다.
디자인 패턴: 정책
"""

from datetime import datetime, timedelta


def should_archive(created_at: str, days: int = 30) -> bool:
    """보관 기간이 지난 메시지인지 판단한다."""
    threshold = datetime.utcnow() - timedelta(days=days)
    return datetime.fromisoformat(created_at.replace("Z", "")) < threshold
```

---

## 7. 실무 고려사항

- **TTL 정책**: 저장소에 남기는 기간을 명확히 해야 한다.
- **재시도/중복 처리**: 동일 메시지가 여러 번 저장될 수 있다.
- **일관성 수준**: 읽기 지연 허용 여부를 정한다.
- **백업/복구**: 장애 발생 시 복원 전략이 필요하다.
- **비용 관리**: 저장 용량과 트래픽 비용을 함께 추적한다.

---

## 8. 구현 체크리스트

- 키 설계가 조회 패턴과 일치하는가?
- 읽기/쓰기 경로가 분리되었는가?
- TTL/보존 정책이 명시되어 있는가?
- 아카이빙/백업 정책이 존재하는가?
