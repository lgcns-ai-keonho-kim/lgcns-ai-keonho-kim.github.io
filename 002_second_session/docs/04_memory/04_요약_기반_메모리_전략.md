# 04. 요약 기반 메모리 전략

## 이 챕터에서 배우는 것

- 요약 기반 메모리의 구조와 장단점
- 요약 생성/갱신 주기 설계 방법
- 요약 품질 기준과 검증 체크리스트
- 초급→중급→고급 튜토리얼 흐름
- 실무에서의 요약 품질/비용/회귀 대응

---

## 1. 요약 기반 메모리란?

요약 기반 메모리는 **오래된 대화내역을 요약으로 대체**해
컨텍스트 길이를 줄이는 전략입니다.

- 장점: 토큰 비용 절감, 긴 대화 유지 가능
- 단점: 요약 품질 저하 시 정보 손실 위험

따라서 **요약 품질 기준과 롤백 규칙**이 중요합니다.

---

## 2. 요약 갱신 주기 설계

대표적인 요약 갱신 방식은 3가지입니다.

- **주기적 요약**: N턴마다 요약을 갱신
- **이벤트 기반 요약**: 중요한 결정/도구 실행 후 요약 갱신
- **하이브리드**: 주기 + 이벤트를 동시에 적용

초급 단계에서는 **주기적 요약**이 가장 단순합니다.

---

## 3. 요약 품질 기준(권장)

요약은 단순 축약이 아니라 **의사결정 중심의 기억**이어야 합니다.

- 사용자 의도/목표가 포함되는가?
- 시스템 제약/정책이 반영되는가?
- 중요한 사실/결정을 보존하는가?
- 모호한 표현을 줄이고 단정적 표현을 피하는가?

---

## 4. 초급 튜토리얼: 요약 여부 결정 노드

### 목표

- `turn_count` 기반으로 요약 여부를 결정한다.

```python
"""
목적: 요약 경로로 분기할지 결정한다.
설명: 턴 수 기준 정책을 적용한다.
디자인 패턴: 정책
"""

from secondsession.core.chat.state.chat_state import ChatState


def decide_summary_node(state: ChatState) -> dict:
    """요약 경로를 결정한다."""
    turn_count = state.get("turn_count", 0)
    route = "summarize" if turn_count >= 5 else "end"
    return {"route": route}
```

---

## 5. 중급 튜토리얼: 요약 생성 노드 설계

### 목표

- 요약 생성 노드를 만들고 summary에 반영한다.

```python
"""
목적: 요약 프롬프트를 사용해 summary를 만든다.
설명: history를 입력으로 넣고 summary 필드를 반환한다.
디자인 패턴: 파이프라인
"""

from secondsession.core.chat.state.chat_state import ChatState
from secondsession.core.chat.prompts.summary_prompt import SUMMARY_PROMPT


def build_summary_input(history: list[dict]) -> str:
    """요약 입력 문자열을 만든다."""
    return "\n".join([f"{m['role']}: {m['content']}" for m in history])


def summary_node(state: ChatState) -> dict:
    """대화 요약을 생성한다."""
    prompt = SUMMARY_PROMPT.format(history=build_summary_input(state.get("history", [])))
    _ = prompt  # 실제 구현에서는 LLM 호출이 들어간다.
    return {"summary": "요약 결과(예시)"}
```

---

## 6. 고급 튜토리얼: 누적 요약(Incremental Summary)

요약을 매번 새로 만들면 비용이 큽니다.
따라서 **기존 요약 + 신규 메시지**만 반영하는 방식이 유리합니다.

```python
"""
목적: 기존 요약과 신규 메시지를 합쳐 새로운 요약을 만든다.
설명: summary를 재사용해 비용을 줄인다.
디자인 패턴: 파이프라인
"""


def build_incremental_input(summary: str | None, new_messages: list[dict]) -> str:
    """기존 요약과 신규 메시지를 결합한다."""
    base = summary or ""
    tail = "\n".join([m["content"] for m in new_messages])
    return f"기존 요약: {base}\n신규 메시지: {tail}"
```

---

## 7. 실무 고려사항

- **요약 회귀 위험**: 요약 품질이 떨어지면 즉시 롤백할 수 있어야 한다.
- **요약 근거 보존**: 요약이 참조한 메시지 범위를 기록한다.
- **결정 사항 고정**: 정책/결정/약속은 요약에서 반드시 유지한다.
- **다국어 처리**: 입력 언어에 맞춰 요약 언어를 고정한다.
- **비용 관리**: 요약 빈도와 길이를 KPI로 관리한다.

---

## 8. 구현 체크리스트

- 요약 갱신 주기가 명확한가?
- 요약 근거 메시지가 추적 가능한가?
- summary와 history의 역할이 분리되어 있는가?
- 요약 품질 기준이 문서화되어 있는가?
