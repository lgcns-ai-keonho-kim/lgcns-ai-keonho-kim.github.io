# 06. 세션 및 스레드 관리

## 이 챕터에서 배우는 것

- 세션과 스레드의 차이와 역할
- thread_id 기반 복구 흐름
- 분기/재개/병합 전략
- 초급→중급→고급 튜토리얼 흐름
- 실무에서의 동시성/중복/재시도 대응

---

## 1. 세션과 스레드의 차이

- **세션(session)**: 사용자와 서비스 간의 장기 대화 단위
- **스레드(thread)**: 세션 안에서 분기된 대화 흐름

즉, **세션은 사용자 단위**, 스레드는 **대화 분기 단위**입니다.

---

## 2. thread_id 기반 복구 흐름

LangGraph는 `thread_id`로 체크포인트 복구를 지원합니다.
같은 `thread_id`를 사용하면 **이전 상태를 이어서 실행**할 수 있습니다.

```python
"""
목적: thread_id를 사용해 대화 흐름을 이어간다.
설명: config의 configurable에 thread_id를 넣는다.
디자인 패턴: Memento
"""


def build_config(thread_id: str) -> dict:
    """LangGraph 실행 설정을 만든다."""
    return {"configurable": {"thread_id": thread_id}}
```

---

## 3. 분기/재개/병합 전략

### 분기 기준 예시

- 사용자가 새 주제를 요청함
- 툴 실행 결과에 따라 대화가 갈라짐

### 병합 기준 예시

- 분기된 스레드를 요약으로 병합
- 핵심 결정만 남기고 스레드를 종료

분기와 병합 기준을 문서화하지 않으면
**동일 세션 내 대화가 꼬일 가능성**이 큽니다.

---

## 4. 초급 튜토리얼: thread_id 생성/전달

```python
"""
목적: 세션/스레드 키를 규칙적으로 생성한다.
설명: user_id와 timestamp를 기반으로 생성한다.
디자인 패턴: Factory
"""

from datetime import datetime


def generate_thread_id(user_id: str) -> str:
    """스레드 식별자를 만든다."""
    ts = datetime.utcnow().strftime("%Y%m%d%H%M%S")
    return f"th-{user_id}-{ts}"
```

이 ID를 `ChatJobRequest.thread_id`에 전달하면
서버가 동일 스레드로 대화를 이어갈 수 있습니다.

---

## 5. 중급 튜토리얼: 동시성 충돌 방지

동일 스레드에 동시에 요청이 들어오면 **순서 충돌**이 발생합니다.
아래 원칙 중 하나를 선택해야 합니다.

- **낙관적 잠금**: 마지막 메시지 버전을 비교
- **순서 보장 큐**: thread_id 단위로 큐를 둔다
- **병렬 허용**: 분기 스레드를 강제로 생성

중급 단계에서는 **순서 보장 큐**가 운영 안정성이 높습니다.

---

## 6. 고급 튜토리얼: 스레드 병합 전략

병합은 일반적으로 **요약 기반**으로 처리합니다.

- 분기 스레드별 요약을 만든다.
- 세션 요약에 병합한다.
- 병합 후 분기 스레드는 종료한다.

```python
"""
목적: 분기 요약을 세션 요약으로 병합한다.
설명: 요약 문자열을 단순 결합해 최종 요약을 만든다.
디자인 패턴: 파이프라인
"""


def merge_summaries(base_summary: str, branch_summary: str) -> str:
    """요약을 병합한다."""
    return f"{base_summary}\n- 분기 요약: {branch_summary}"
```

---

## 7. 실무 고려사항

- **중복 요청 처리**: 동일 요청이 재시도될 수 있다.
- **멀티 디바이스**: 한 사용자가 여러 기기에서 동시에 요청할 수 있다.
- **세션 만료**: 일정 기간 후 세션을 종료하고 보관 정책을 적용한다.
- **추적성**: trace_id와 thread_id를 함께 로깅해야 한다.
- **스레드 폭발 방지**: 분기가 과도하면 비용이 증가한다.

---

## 8. 구현 체크리스트

- session_id와 thread_id가 명확히 구분되는가?
- thread_id를 통해 체크포인트 복구가 가능한가?
- 분기/병합 기준이 문서화되어 있는가?
- 동시성 충돌에 대한 정책이 정의되어 있는가?
