# 02. 메시지 타입과 정규화

## 이 챕터에서 배우는 것

- 메시지 타입 분류 기준(Human/AI/System/Tool)
- 내부 표준 메시지 포맷 설계 방법
- 정규화(Adapter) 파이프라인 구성
- 초급→중급→고급 튜토리얼 흐름
- 실무에서 흔한 메시지 정합성 문제와 해결책

---

## 1. 메시지 타입을 구분하는 이유

메시지 타입은 **정책과 라우팅의 기준**이 됩니다.
타입이 섞이면 트리밍/요약/보안 정책이 뒤섞여 품질이 급락합니다.

- **Human**: 사용자 입력(질문/요청)
- **AI**: 모델 출력(응답/설명)
- **System**: 규칙/가드레일/역할 지시
- **Tool**: 툴 호출 요청/응답 결과

---

## 2. 내부 표준 포맷(권장)

외부 입력은 형태가 제각각이므로 내부 포맷으로 통일합니다.
최소 필드는 다음을 권장합니다.

- `role`: 역할(user/assistant/system/tool)
- `content`: 텍스트 본문
- `created_at`: ISO8601 타임스탬프
- `metadata`: 채널/요청자/툴 정보 등

```python
"""
목적: 내부 표준 메시지 포맷 예시를 보여준다.
설명: 최소 필드를 포함한 딕셔너리 구조다.
디자인 패턴: Value Object
"""

message = {
    "role": "user",
    "content": "환불 정책 알려줘",
    "created_at": "2026-01-29T09:00:00Z",
    "metadata": {"channel": "web", "locale": "ko-KR"},
}
```

---

## 3. 정규화(Adapter) 파이프라인

정규화는 **외부 입력 → 내부 포맷** 변환 과정입니다.
보통 아래 순서를 권장합니다.

1) 외부 요청 파싱
2) 메시지 타입 결정
3) 내부 포맷으로 변환
4) 스키마 검증
5) 상태 history에 추가

```python
"""
목적: 외부 메시지를 내부 포맷으로 정규화한다.
설명: 역할/메타데이터를 보강해 일관된 구조로 만든다.
디자인 패턴: 어댑터
"""

from datetime import datetime


def normalize_message(raw: dict, role: str) -> dict:
    """외부 입력을 내부 메시지 포맷으로 변환한다."""
    return {
        "role": role,
        "content": raw.get("content", ""),
        "created_at": raw.get("created_at") or datetime.utcnow().isoformat() + "Z",
        "metadata": raw.get("metadata", {}),
    }
```

---

## 4. 초급 튜토리얼: 사용자 입력을 정규화하기

### 목표

- `ChatJobRequest`의 `query`를 내부 포맷으로 변환한다.

### 단계

1) `query`를 `content`로 매핑
2) `role`을 `user`로 고정
3) `created_at`을 부여

```python
"""
목적: 사용자 입력을 내부 포맷으로 정규화한다.
설명: role/user 고정 규칙을 적용한다.
디자인 패턴: 어댑터
"""

from datetime import datetime


def normalize_user_query(query: str) -> dict:
    """사용자 입력을 내부 메시지로 변환한다."""
    return {
        "role": "user",
        "content": query,
        "created_at": datetime.utcnow().isoformat() + "Z",
        "metadata": {},
    }
```

---

## 5. 중급 튜토리얼: Tool 메시지 구조화

Tool 메시지는 **요청/응답 구조**가 섞여 들어오기 쉽습니다.
따라서 아래처럼 필드를 명확히 분리합니다.

```python
"""
목적: 툴 호출 메시지를 표준 구조로 만든다.
설명: tool_name과 결과를 메타데이터에 분리한다.
디자인 패턴: 어댑터
"""


def normalize_tool_result(tool_name: str, result: dict) -> dict:
    """툴 결과 메시지를 정규화한다."""
    return {
        "role": "tool",
        "content": result.get("content", ""),
        "created_at": result.get("created_at"),
        "metadata": {
            "tool_name": tool_name,
            "tool_args": result.get("args"),
            "tool_result": result.get("data"),
        },
    }
```

이렇게 분리하면 **트리밍/요약 정책**에서 tool 메시지를 별도 처리할 수 있습니다.

---

## 6. 고급 튜토리얼: 멀티모달/스트리밍 정규화

실무에서는 이미지/파일/스트리밍 조각이 들어옵니다.
이때는 다음 원칙을 지킵니다.

- 멀티모달은 `metadata.attachments`로 분리
- 스트리밍 조각은 **완결 시점에 단일 메시지로 합성**
- `message_id`로 중복 삽입을 방지

```python
"""
목적: 스트리밍 조각을 합성할 때 사용할 키를 정의한다.
설명: message_id로 중복 처리를 막는다.
디자인 패턴: Value Object
"""


def build_message_id(trace_id: str, seq: int) -> str:
    """스트리밍 메시지 식별자를 만든다."""
    return f"{trace_id}:{seq}"
```

---

## 7. 실무 고려사항

- **역할 혼선 방지**: system/user/assistant가 섞이면 안전 정책이 깨진다.
- **타임존 통일**: created_at은 반드시 UTC로 저장한다.
- **길이 제한**: 콘텐츠가 과도하면 저장/요약 정책이 실패한다.
- **로케일/채널 메타데이터**: 채널별 응답 톤을 바꾸려면 필수
- **역사적 호환성**: 메시지 스키마 버전을 저장해 마이그레이션을 대비한다.

---

## 8. 구현 체크리스트

- role/content/created_at/metadata가 일관된가?
- 외부 입력이 내부 포맷으로 모두 변환되는가?
- Tool 메시지가 구조적으로 분리되는가?
- 스키마 버전이 기록되는가?
