# 03. 컨텍스트 윈도우 및 트리밍

## 이 챕터에서 배우는 것

- 컨텍스트 윈도우와 토큰 예산의 의미
- 최근/중요도/요약 기반 트리밍 전략
- 트리밍 정책을 전략 패턴으로 분리하는 방법
- 초급→중급→고급 튜토리얼 흐름
- 실무에서 발생하는 품질/비용 문제와 대응

---

## 1. 컨텍스트 윈도우란?

모델은 **입력 토큰 한도**가 있습니다.
대화가 길어질수록 전체 히스토리를 넣기 어렵기 때문에
**트리밍(축약) 정책**이 필요합니다.

- 길이 초과 → 모델 입력 오류/비용 폭증
- 길이 부족 → 맥락 손실/품질 저하

---

## 2. 대표 트리밍 전략

- **최근 N개 유지**: 가장 단순, 초급에서 권장
- **중요도 기반 유지**: 시스템/정책/결정 메시지 우선
- **요약 전환**: 오래된 대화를 요약으로 대체
- **하이브리드**: 최근 N개 + 요약 + 시스템 메시지 유지

---

## 3. 전략 패턴으로 트리밍 정책 분리

트리밍은 모델/서비스 정책에 따라 계속 바뀝니다.
따라서 **정책을 코드에서 분리**해 교체 가능하게 만드는 것이 좋습니다.

```python
"""
목적: 트리밍 정책을 함수로 분리한다.
설명: 입력 메시지 목록과 제한 수를 받아 잘라낸다.
디자인 패턴: 전략
"""


def trim_recent_messages(messages: list[dict], keep_last: int) -> list[dict]:
    """최근 N개 메시지만 유지한다."""
    if keep_last <= 0:
        return []
    return messages[-keep_last:]
```

---

## 4. 초급 튜토리얼: 최근 N개 유지

### 목표

- 가장 단순한 트리밍 정책을 적용한다.

### 단계

1) `history` 길이를 제한값으로 자른다.
2) 시스템 메시지가 있다면 먼저 보존한다.

```python
"""
목적: 최근 N개 메시지를 유지한다.
설명: 시스템 메시지는 별도로 보존한다.
디자인 패턴: 전략
"""


def trim_keep_system(messages: list[dict], keep_last: int) -> list[dict]:
    """시스템 메시지를 유지하면서 최근 메시지를 보존한다."""
    system_msgs = [m for m in messages if m.get("role") == "system"]
    rest = [m for m in messages if m.get("role") != "system"]
    return system_msgs + rest[-keep_last:]
```

---

## 5. 중급 튜토리얼: 요약 + 최근 메시지 조합

### 목표

- 오래된 메시지를 요약으로 대체한다.
- `summary`는 상태에 별도 저장한다.

### 핵심 규칙

- `summary`는 **한 줄 요약**이 아니라 **결정/맥락 중심**으로 만든다.
- 최근 메시지는 그대로 유지한다.

```python
"""
목적: 요약과 최근 메시지를 조합해 컨텍스트를 구성한다.
설명: summary는 가장 앞에 배치한다.
디자인 패턴: 파이프라인
"""


def build_context(summary: str | None, recent_messages: list[dict]) -> list[dict]:
    """요약과 최근 메시지를 합쳐 컨텍스트를 만든다."""
    if not summary:
        return recent_messages
    return [{"role": "system", "content": f"요약: {summary}"}] + recent_messages
```

---

## 6. 고급 튜토리얼: 토큰 예산 기반 트리밍

실무에서는 **토큰 예산 기반**이 더 안정적입니다.
대략적인 토큰 수를 계산해 예산을 넘지 않게 제한합니다.

```python
"""
목적: 토큰 예산을 넘지 않도록 메시지를 선택한다.
설명: 길이 기반 근사치로 토큰 수를 추정한다.
디자인 패턴: 전략
"""


def trim_by_budget(messages: list[dict], budget: int) -> list[dict]:
    """간단한 길이 기반 근사치로 메시지를 제한한다."""
    selected: list[dict] = []
    total = 0
    for msg in reversed(messages):
        cost = len(msg.get("content", ""))
        if total + cost > budget:
            break
        selected.append(msg)
        total += cost
    return list(reversed(selected))
```

정확한 토큰 계산은 모델마다 달라집니다.
따라서 **근사치 + 안전 마진**을 두는 것이 현실적입니다.

---

## 7. 실무 고려사항

- **시스템 메시지 보존**: 규칙/가드레일은 반드시 남겨야 한다.
- **도구 결과 보존**: 툴 실행 결과가 누락되면 환각이 늘어난다.
- **컨텍스트 품질 회귀**: 트리밍 정책 변경 시 A/B 테스트가 필요하다.
- **로그 기록**: 트리밍 전/후 길이를 기록해 원인 분석 가능하게 한다.
- **모델별 예산 관리**: 모델 교체 시 예산 값도 재조정해야 한다.

---

## 8. 구현 체크리스트

- 토큰 예산을 초과하지 않는가?
- 시스템 메시지가 유지되는가?
- 요약/최근 메시지가 적절히 조합되는가?
- 트리밍 기준이 문서화되어 있는가?
