# 02. 토큰 스트리밍 포맷

## 이 챕터에서 배우는 것

- 토큰 스트리밍 포맷의 기본 규약
- 이벤트 타입과 필수 필드 설계
- 노드/상태 정보를 토큰 이벤트에 포함하는 방법
- 비동기 실행에서 seq/trace_id 규칙
- 토큰 경계/순서/완결성 보장 방법
- LangGraph 이벤트를 토큰 스트림으로 변환하는 방법
- 실전에서 쓰이는 SSE 라인 구성

---

## 1. 기본 규약(SSE 기반)

스트리밍은 **SSE(Server-Sent Events)** 형태가 가장 단순합니다.
한 이벤트는 보통 다음 형태로 전달합니다.

```bash
data: {"type": "token", "content": "<SOME_TOKEN>"}
```

- `data:` 이후는 **JSON 문자열**
- 이벤트 구분은 **빈 줄(\n\n)**

---

## 2. 이벤트 타입과 스키마

토큰만 보내면 운영이 불편합니다. 최소한 다음 타입을 포함합니다.

- **token**: 생성된 텍스트 조각
- **metadata**: 노드/라우팅/폴백 상태
- **error**: 실패 원인
- **done**: 종료 신호
- **heartbeat**: 연결 유지(선택)

```python
"""
목적: 스트리밍 이벤트 공통 구조를 예시로 보여준다.
설명: 최소 필드만 포함한 딕셔너리 형태로 구성한다.
디자인 패턴: Value Object
"""

stream_event = {
    "type": "token",
    "content": "안녕하세요",
    "trace_id": "t-123",
    "node": "generate",
    "seq": 2,
    "timestamp": "2026-01-27T10:00:01Z",
}
```

---

## 3. 노드/상태 정보 포함하기

토큰 스트리밍만으로는 **어느 노드에서 생성된 토큰인지** 알기 어렵습니다.
따라서 `node`, `route`, `error_code` 같은 필드를 포함하는 것을 권장합니다.

```python
"""
목적: 토큰 이벤트에 노드/상태 정보를 포함한다.
설명: 토큰의 출처와 라우팅 정보를 함께 전달한다.
디자인 패턴: Value Object
"""

token_event = {
    "type": "token",
    "content": "안녕하세요",
    "trace_id": "t-123",
    "node": "generate",
    "route": "generate",
    "error_code": None,
    "seq": 2,
}
```

---

## 4. 비동기 실행에서의 seq/trace_id 규칙

워커/큐 분리 환경에서는 **이벤트가 비동기로 생산/소비**됩니다.
따라서 다음 규칙이 필요합니다.

- **seq 단조 증가**: job_id별로 seq를 1씩 증가
- **trace_id 고정**: 요청 단위 식별자는 모든 이벤트에 동일하게 포함
- **done 보장**: 워커가 `done` 이벤트를 반드시 적재
- **error 분리**: 토큰 스트림과 에러 이벤트를 구분

이 규칙이 없으면 **재연결/재시도 시 스트림이 깨집니다**.

`done`은 **자동으로 생성되지 않으므로**, 워커가 **마지막에 직접 추가**해야 합니다.

---

## 5. 토큰 경계와 순서 보장

LLM 토큰은 **문장 경계와 일치하지 않을 수 있습니다**.
따라서 클라이언트는 다음을 고려해야 합니다.

- **순서 보장**: `seq`로 순서 확인
- **재조립**: `content`를 순서대로 누적
- **완결성**: `done` 이벤트에서 종료

---

## 6. LangGraph 이벤트를 토큰 스트림으로 변환(실전)

아래 예시는 **01 문서의 `get_node_name` 규칙을 그대로 적용**합니다.

```python
"""
목적: LangGraph 이벤트를 바로 SSE용 토큰 이벤트로 변환한다.
설명: 이벤트 타입을 보고 token/metadata/error를 구분한다.
디자인 패턴: Pipeline
"""

def stream_from_graph_events(graph_events: list[dict], trace_id: str) -> None:
    seq = 0
    for event in graph_events:
        seq += 1
        event_type = event.get("type")
        node = event.get("node") or event.get("name") or event.get("metadata", {}).get("node")

        if event_type == "llm_token":
            enqueue_event({
                "type": "token",
                "content": event.get("content"),
                "node": node,
                "trace_id": trace_id,
                "seq": seq,
            })
            continue

        if event_type == "node_end":
            enqueue_event({
                "type": "metadata",
                "content": f"node_end:{node}",
                "node": node,
                "trace_id": trace_id,
                "seq": seq,
            })
            continue

        if event_type == "error":
            enqueue_event({
                "type": "error",
                "content": event.get("message", "unknown_error"),
                "node": node,
                "trace_id": trace_id,
                "seq": seq,
            })
            continue

    # 실행 종료 신호는 워커가 직접 추가한다
    enqueue_event({
        "type": "done",
        "content": None,
        "node": None,
        "trace_id": trace_id,
        "seq": seq + 1,
    })
```

---

## 7. SSE 라인 생성 예시

```python
"""
목적: 스트리밍 이벤트를 SSE 라인으로 직렬화한다.
설명: JSON 직렬화 후 data 라인 형식으로 감싼다.
디자인 패턴: Adapter
"""

import json


def to_sse_line(event: dict) -> str:
    """SSE 데이터 라인을 생성한다."""
    payload = json.dumps(event, ensure_ascii=False)
    return f"data: {payload}\n\n"
```

---

## 8. 실전 이벤트 예시

```bash
data: {"type": "metadata", "content": "node_start:retrieve", "trace_id": "t-123", "node": "retrieve", "seq": 1, "timestamp": "2026-01-27T10:00:00Z"}

data: {"type": "token", "content": "안녕하세요", "trace_id": "t-123", "node": "generate", "seq": 2, "timestamp": "2026-01-27T10:00:01Z"}

data: {"type": "token", "content": "!", "trace_id": "t-123", "node": "generate", "seq": 3, "timestamp": "2026-01-27T10:00:01Z"}

data: {"type": "done", "content": null, "trace_id": "t-123", "node": null, "seq": 4, "timestamp": "2026-01-27T10:00:02Z"}
```

---

## 9. 안티패턴

- `done` 이벤트 없이 연결 종료
- 토큰 이벤트에 `seq` 없이 전송
- 에러 발생 시 `error` 이벤트 누락
- 로그/디버그 문자열을 토큰 스트림에 섞기

---

## 10. 구현 체크리스트

- SSE 포맷(`data: ...\n\n`)이 지켜지는가?
- `type/trace_id/seq`가 필수로 포함되는가?
- 노드 이름(`node`)을 포함하는가?
- `done` 이벤트가 항상 전송되는가?
- 토큰 재조립이 가능한 구조인가?
- 에러 이벤트가 사용자 메시지와 분리되어 있는가?
