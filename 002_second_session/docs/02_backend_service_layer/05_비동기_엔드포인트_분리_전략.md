# 05. 비동기 실행을 위한 엔드포인트 분리 전략

## 이 챕터에서 배우는 것

- 요청/스트리밍 엔드포인트 분리의 이유
- job_id 기반 스트리밍 프로토콜 설계
- 재시도/보안/취소를 고려한 API 흐름
- 실전 서비스 레이어 구성 패턴
- FastAPI 기반 엔드포인트 분리 구현 예시
- 워커/큐 분리와 비동기 실행 모델
- 상태/취소 엔드포인트 설계

---

## 1. 왜 엔드포인트를 분리해야 하는가?

LLM 응답은 생성 시간이 길어 **단일 요청-응답 구조**로 처리하기 어렵습니다.
엔드포인트 분리는 다음을 가능하게 합니다.

- **요청/스트리밍 분리**로 확장성 확보
- **장시간 연결 분리**로 서버 안정성 향상
- **재시도/복구**에 유리

---

## 2. 기본 흐름

1) **요청 엔드포인트**: 작업 생성 → `job_id` 반환
2) **스트리밍 엔드포인트**: `job_id`로 이벤트 소비
3) **워커**: 큐에서 작업을 가져와 LangGraph 실행

```text
POST /jobs  ->  {"job_id": "job-123"}
GET  /stream/job-123  ->  SSE 스트림
```

---

## 3. 비동기 실행 구성 요소

- **API 서버**: job_id 발급, 스트리밍 전달
- **큐/Redis**: 작업과 이벤트 버퍼
- **워커**: LangGraph 실행 및 이벤트 생성

이 구조는 **요청-실행-전달을 완전히 분리**합니다.

---

## 4. 실전 API 계약 예시

```python
"""
목적: 요청/스트리밍 엔드포인트 계약을 예시로 보여준다.
설명: 최소 필드만 포함한 딕셔너리 형태로 구성한다.
디자인 패턴: Command, Query
"""

create_job_request = {
    "query": "환불 정책 알려줘",
    "user_id": "user-123",
}

create_job_response = {
    "job_id": "job-abc123",
}
```

---

## 5. FastAPI 구현 예시(비동기 실행)

```python
"""
목적: 엔드포인트 분리 구조를 FastAPI로 구현한다.
설명: 요청은 큐에 적재하고, 워커가 실행을 담당한다.
디자인 패턴: Command, Query
"""

import time
import uuid
from fastapi import FastAPI
from fastapi.responses import StreamingResponse

app = FastAPI()


def enqueue_job(job_id: str, query: str) -> None:
    """작업을 큐에 적재한다."""
    push_job_to_queue({"job_id": job_id, "query": query})


def stream_events(job_id: str):
    """Redis 큐를 폴링해 SSE 이벤트를 전송한다."""
    while True:
        event = pop_event_from_redis(job_id)
        if event is None:
            time.sleep(0.1)
            continue
        yield to_sse_line(event)
        if event["type"] == "done":
            break


@app.post("/jobs")
def create_job(payload: dict):
    job_id = f"job-{uuid.uuid4().hex}"
    enqueue_job(job_id, payload["query"])
    return {"job_id": job_id}


@app.get("/stream/{job_id}")
def stream_job(job_id: str):
    return StreamingResponse(
        stream_events(job_id),
        media_type="text/event-stream",
        headers={"Cache-Control": "no-cache"},
    )
```

워커는 **별도 프로세스**로 실행되어 큐에서 작업을 소비합니다.

---

## 6. 추가 엔드포인트(권장)

비동기 실행에서는 상태/취소 엔드포인트가 필요합니다.

- `GET /jobs/{job_id}/status`: 대기/실행/완료/실패
- `POST /jobs/{job_id}/cancel`: 취소 요청

---

## 7. 실전 시나리오(중급/고급)

### 시나리오 A: 채팅 응답 스트리밍

- 요청: `POST /jobs`로 질문 전달
- 응답: `job_id` 반환
- 스트리밍: `GET /stream/{job_id}`에서 토큰 + 메타데이터 수신

### 시나리오 B: 비동기 리포트 생성

- 요청: 긴 배치/리포트 작업 생성
- 스트리밍: 진행률/중간 결과 전달
- 완료: `done` 이벤트로 종료

### 시나리오 C: 재시도/복구

- 네트워크 단절 시 `job_id` 재연결
- 마지막 `seq` 이후 이벤트부터 재수신

---

## 8. 보안/운영 고려사항

- **인증/인가**: `job_id` 접근 권한 검증
- **TTL 관리**: 완료된 작업은 자동 정리
- **중복 요청 방지**: idempotency key 사용
- **취소 API**: 사용자 취소 지원

---

## 9. 구현 체크리스트

- 요청/스트리밍 엔드포인트가 분리되어 있는가?
- `job_id`가 안전하게 생성/관리되는가?
- 재연결/재시도 흐름이 정의되어 있는가?
- 인증/인가가 스트리밍에도 적용되는가?
- 종료/정리 정책이 문서화되어 있는가?
