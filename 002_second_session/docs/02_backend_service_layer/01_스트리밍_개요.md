# 01. 스트리밍 개요

## 이 챕터에서 배우는 것

- 서비스 레이어에서 스트리밍이 필요한 이유
- LangGraph 실행과 스트리밍 전달의 책임 분리
- 비동기 실행을 위한 워커/큐 아키텍처
- 스트리밍 이벤트의 기본 구조와 설계 원칙
- 특정 노드 이름 접근 방법
- FastAPI 기반 최소 스트리밍 스켈레톤

---

## 1. 스트리밍이 필요한 이유

LLM 기반 응답은 **생성 시간이 길고 결과 크기가 크기** 때문에,
완료 후 일괄 응답만 제공하면 사용자 경험이 크게 나빠집니다.

스트리밍은 다음 이점을 제공합니다.

- **체감 지연 감소**: 첫 토큰을 빨리 보여줌
- **진행 상황 공유**: 중간 단계/상태를 전달
- **부분 결과 활용**: 완전 실패 전에도 가치 제공
- **운영 관측성 개선**: 어디에서 지연/실패가 발생하는지 가시화

---

## 2. 비동기 실행 아키텍처(Worker/Queue)

실전 환경에서는 **API 서버가 그래프를 직접 실행하지 않습니다**.
보통 아래처럼 **워커/큐 분리 구조**를 사용합니다.

- **API 서버**: 요청 수신, job_id 발급, 스트리밍 전송
- **워커**: LangGraph 실행, 이벤트 생성
- **큐/Redis**: 이벤트 버퍼(토큰/메타데이터/에러/종료)

이 구조는 **요청 처리(HTTP)와 실행 처리(백그라운드)**를 분리해
**스케일링/격리/복구**를 쉽게 만듭니다.

### 용어 설명

- **워커(Worker)**: 백그라운드에서 무거운 작업을 처리하는 실행 주체입니다.  
  예: LangGraph 그래프를 실제로 실행하고, 토큰/메타데이터를 생성합니다.
- **큐(Queue)**: 작업과 이벤트를 순서대로 쌓아두는 임시 저장소입니다.  
  예: API 서버가 job_id를 넣고, 워커가 꺼내 실행하거나,  
  워커가 생성한 이벤트를 스트리밍 엔드포인트가 꺼내 전송합니다.

즉, **API 서버는 “요청 받기/전달하기”에 집중**하고,  
**워커는 “실행하기”에 집중**하도록 역할을 나누는 구조입니다.

### 다이어그램

```text
[Client]
   |  POST /jobs
   v
[API 서버] ----enqueue job----> [Queue/Redis] ----dequeue----> [Worker]
   |                                                         |
   |                         events rpush                    |
   +--------------------<-------------------------------+     |
   |                                                        LangGraph 실행
   |  GET /stream/{job_id}                                   |
   v                                                         |
[Streaming 엔드포인트] <---lpop events--- [Queue/Redis] <-----+
```

---

## 3. 책임 분리(Execution vs Delivery)

스트리밍은 **그래프 실행**과 **전달 채널**을 분리해야 안정적입니다.

- **Execution(그래프 실행)**: LangGraph가 상태 전이와 노드 실행
- **Delivery(전달 채널)**: API 서버가 SSE/WebSocket으로 전달

이 분리를 통해 **재시도/확장/보안**이 쉬워집니다.

---

## 4. 토큰 생성 흐름(LLM → LangGraph → 서비스 레이어)

토큰은 보통 다음 흐름으로 전달됩니다.

1) **LLM 스트리밍**: 모델이 토큰/청크를 생성
2) **LangGraph 이벤트 스트림**: 노드 실행/토큰 이벤트가 섞여 전달
3) **서비스 레이어**: 이벤트에서 토큰/노드 정보를 추출해 SSE로 전송

핵심은 **“토큰 이벤트에 노드/상태 정보를 붙인다”**는 점입니다.

---

## 5. 스트리밍 이벤트 기본 구조

스트리밍은 단일 토큰 뿐 아니라 **메타데이터/에러/완료 신호**를 포함해야 합니다.

- **token**: LLM 토큰 또는 부분 문자열
- **metadata**: 노드 시작/종료, 라우팅, 폴백 발생
- **error**: 처리 실패 원인
- **done**: 스트리밍 종료 신호
- **heartbeat**: 연결 유지용 신호(선택)

`done` 이벤트는 **자동으로 생기지 않으며**, 워커가 **그래프 실행 종료 시점에 명시적으로 적재**해야 합니다.

---

## 6. State에서 꺼내야 할 필드(권장)

초보자가 많이 놓치는 부분은 **State의 어떤 값을 스트리밍에 담아야 하는지**입니다.

- **trace_id**: 요청 단위 식별자
- **run_id**: 그래프 실행 단위 식별자(선택)
- **route**: 라우팅 결과(경로 이름)
- **error_code**: 폴백/에러 시 코드
- **user_message**: 사용자에게 보여줄 메시지
- **seq**: 이벤트 순서(토큰 재조립용)

이 필드를 기준으로 **토큰/메타데이터/에러 이벤트**를 구성합니다.

---

## 7. 특정 노드 이름 접근 방법

LangGraph 이벤트에서 **노드 이름은 항상 같은 키에 있지 않을 수 있습니다**.
그래서 아래처럼 **우선순위를 두고 추출**하는 방식이 안전합니다.

```python
"""
목적: 이벤트에서 노드 이름을 안전하게 추출한다.
설명: node → name → metadata 순으로 확인한다.
디자인 패턴: Adapter
"""

def get_node_name(event: dict) -> str | None:
    node = event.get("node")
    if node:
        return node
    name = event.get("name")
    if name:
        return name
    metadata = event.get("metadata", {})
    return metadata.get("node") or metadata.get("name")


# 특정 노드만 처리하는 예시
raw_event = {"type": "llm_token", "node": "generate"}
node = get_node_name(raw_event)
if node == "generate":
    handle_generate_node(raw_event)
```

---

## 8. 최소 스켈레톤(개념 코드)

```python
"""
목적: LangGraph 이벤트를 받아 SSE 이벤트로 변환한다.
설명: 토큰/메타데이터/에러를 바로 큐로 전달한다.
디자인 패턴: Pipeline
"""

def stream_from_graph_events(graph_events: list[dict], state: dict) -> None:
    seq = 0
    trace_id = state.get("trace_id", "unknown")

    for raw_event in graph_events:
        seq += 1
        event_type = raw_event.get("type", "metadata")
        node = raw_event.get("node") or raw_event.get("name") or raw_event.get("metadata", {}).get("node")

        enqueue_event({
            "type": event_type,
            "content": raw_event.get("content"),
            "node": node,
            "trace_id": trace_id,
            "seq": seq,
        })

    # 실행이 끝났으면 종료 신호를 명시적으로 적재
    enqueue_event({
        "type": "done",
        "content": None,
        "node": None,
        "trace_id": trace_id,
        "seq": seq + 1,
    })
```

---

## 9. FastAPI 최소 구현 스케치(비동기 실행)

FastAPI에서는 **asyncio를 직접 쓰지 않아도**
`StreamingResponse` + 동기 제너레이터로 스트리밍을 구현할 수 있습니다.

```python
"""
목적: FastAPI에서 비동기 실행 흐름을 구성한다.
설명: 요청은 job_id만 반환하고, 실행은 워커가 수행한다.
디자인 패턴: Command, Query, Producer-Consumer
"""

import time
import uuid
from fastapi import FastAPI
from fastapi.responses import StreamingResponse

app = FastAPI()


def enqueue_job(job_id: str, query: str) -> None:
    """작업 요청을 큐에 적재한다."""
    push_job_to_queue({"job_id": job_id, "query": query})


def stream_events(job_id: str):
    """Redis 큐를 폴링하며 SSE 이벤트를 전송한다."""
    while True:
        event = pop_event_from_redis(job_id)
        if event is None:
            time.sleep(0.1)
            continue
        yield to_sse_line(event)
        if event["type"] == "done":
            break


@app.post("/jobs")
def create_job(payload: dict):
    """작업을 생성하고 job_id를 반환한다."""
    job_id = f"job-{uuid.uuid4().hex}"
    enqueue_job(job_id, payload["query"])
    return {"job_id": job_id}


@app.get("/stream/{job_id}")
def stream_job(job_id: str):
    """SSE 스트리밍 엔드포인트."""
    return StreamingResponse(
        stream_events(job_id),
        media_type="text/event-stream",
        headers={"Cache-Control": "no-cache"},
    )
```

위 구조에서 **그래프 실행은 워커 프로세스가 담당**합니다.
API 서버는 **job 생성과 스트리밍 전송**에만 집중합니다.

---

## 10. 실전 아키텍처 스케치

```
[Client] ──(요청)──> [API: 요청 엔드포인트]
    │                      │
    │                  (job_id 반환)
    │                      │
    └─(SSE 연결)──> [API: 스트리밍 엔드포인트]
                           │
                     [Redis/Queue]
                           │
                        [Worker]
                           │
                      [LangGraph]
```

- 요청 엔드포인트: 작업 생성, job_id 반환
- 스트리밍 엔드포인트: job_id로 큐에서 이벤트 소비
- 워커: 그래프 실행과 이벤트 생산

---

## 11. 사용 흐름 예시(개념)

```python
"""
목적: 실행과 전달을 분리한 스트리밍 구조를 설명한다.
설명: 워커는 이벤트를 큐에 넣고, API는 큐에서 꺼내 SSE로 전달한다.
디자인 패턴: Producer-Consumer
"""

def worker_producer(event: dict) -> None:
    """워커 실행 중 이벤트를 큐에 적재한다."""
    enqueue_event(event)


def api_consumer(trace_id: str) -> str:
    """큐에서 이벤트를 읽어 SSE 라인으로 변환한다."""
    event = dequeue_event(trace_id)
    return f"data: {{\"type\": \"{event['type']}\", \"content\": \"{event['content']}\"}}\n\n"
```

---

## 12. 스트리밍 설계 원칙

- **순서 보장**: 토큰/이벤트 순서를 유지
- **완결성 보장**: `done` 이벤트로 종료를 명시
- **부분 실패 허용**: 실패 정보를 전달하고 종료
- **취소 가능성**: 클라이언트 취소/타임아웃 처리
- **관측 가능성**: trace_id, run_id를 포함

---

## 13. 구현 체크리스트

- 실행과 전달이 분리되어 있는가?
- 워커/큐 구조가 명확히 정의되어 있는가?
- `token/metadata/error/done` 이벤트가 정의되어 있는가?
- 스트리밍 종료 신호가 명확한가?
- 관측 가능한 식별자(trace_id, run_id)가 포함되는가?
- 재시도/취소 시나리오가 고려되어 있는가?
