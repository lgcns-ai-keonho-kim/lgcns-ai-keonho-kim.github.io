# 01. Tool 설계 기본

## 이 챕터에서 배우는 것

- Tool을 “기획 → 설계 → 구현 → 운영” 흐름으로 설계하는 방법
- Tool과 MCP의 역할을 **명확히 분리**하는 기준
- 공통 컴포넌트를 미리 분리해 **확장 가능한 구조**를 만드는 방법
- SI 기업 관점에서 **실무 레벨 예시**로 이해하기

이 문서는 **초보자부터 고급자까지** 이어지는 튜토리얼입니다.  
처음에는 “왜 Tool이 필요한지”를 이해하고, 이후 설계/운영 관점으로 확장합니다.  
코드보다 **설계 판단 기준**을 먼저 읽고, 예제는 그 다음에 확인하세요.

---

## 1. Tool 설계는 기획부터 시작한다

여기서 “기획”은 **서비스 기획**이 아니라, **어떤 프로그램을 어떻게 만들지**를 정하는 과정입니다.

### 1-1) 설계 진행 순서

1. **업무 시나리오를 정의한다**
   - 누가, 어떤 문제를 해결하는지부터 정한다.
   - 예: “영업 담당자가 특정 고객의 미결제 내역을 조회한다.”

2. **책임 경계를 확정한다**
   - Tool이 할 일과 MCP가 할 일을 먼저 분리한다.
   - Tool은 **실제 실행**, MCP는 **발견/통제/관측**을 담당한다.
   - 헷갈리는 경우에는 “범용성”이 아니라 **실행 vs 통제**로 구분한다.

3. **입력/출력 스키마를 고정한다**
   - 필드명, 타입, 필수 여부를 문서화한다.
   - 예외는 구조화된 에러 코드로 반환한다.

4. **공통 컴포넌트를 분리한다**
   - 인증/권한, 로깅, 에러 매핑, 재시도 정책을 공통으로 둔다.
   - 이후 Tool이 늘어나도 공통 기준이 유지된다.

5. **운영 정책을 정의한다**
   - 타임아웃, 재시도, 캐시, 멱등 키 정책을 확정한다.
   - 장애 시 어떤 로그를 남길지도 정한다.

6. **확장 전략을 마련한다**
   - Tool 추가 시 어떤 경로로 등록되는지 정한다.
   - 버전 정책과 하위 호환 기준을 문서화한다.

---

## 2. Tool과 MCP의 역할 분리

Tool과 MCP는 반드시 구분되어야 합니다. “실행”과 “통제”를 섞으면 운영이 어려워집니다.

### 2-1) Tool이 되어야 하는 것

- **실제 실행**: 조회, 생성, 수정, 삭제 같은 실제 동작
- **외부 시스템 연동**: ERP/CRM/HR/DMS 같은 시스템 호출
- **명확한 입력/출력 스키마**: 안정적인 구조
- **부작용 관리**: 쓰기 작업은 멱등 키로 제어

외부 시스템 연동은 “실제 실행”이므로 Tool 책임입니다. MCP가 실행까지 맡으면 운영 리스크가 커집니다.  
다음 항목은 실무에서 자주 맞닥뜨리는 구체적인 이유입니다.

- **역할 분리**: MCP는 발견/통제/관측, Tool은 실행을 담당해야 책임이 명확해진다.  
  실행이 MCP에 섞이면 문제 발생 시 “정책 문제인지 실행 문제인지” 구분이 어려워진다.
- **장애 격리**: 외부 시스템 장애가 **MCP 전체 장애**로 번지는 것을 막아야 한다.  
  Tool로 분리하면 실패가 **특정 Tool 범위**에만 머문다.
- **확장성**: 연동 대상이 늘수록 실행 로직이 커진다.  
  MCP에 몰리면 **단일 병목**이 되고, Tool 분리로 수평 확장이 가능해진다.
- **보안/감사 일관성**: 권한/감사는 MCP에서 일관되게 강제하고, 실행 로직은 Tool에서 처리한다.  
  실행까지 MCP가 맡으면 정책 변경이 실행 로직과 섞여 **감사 기준이 흔들린다**.
- **배포/변경 분리**: 외부 시스템 스펙 변경은 잦다.  
  Tool만 배포하면 되도록 분리하면 **배포 범위와 위험이 줄어든다**.
- **재시도/회로 차단 분리**: MCP는 호출 정책을, Tool은 실행 오류를 관리한다.  
  실행이 MCP에 섞이면 **재시도 기준이 중앙에 과도하게 집중**된다.

실무에서 겪을 수 있는 예시

1) ERP 장애로 응답 지연 발생  
2) MCP가 실행까지 맡고 있으면 **MCP 전체 응답 지연** → 다른 Tool까지 영향  
3) Tool로 분리되어 있으면 **ERP Tool만 지연/실패**  
4) MCP는 도구 카드 제공과 정책 집행을 유지하고, **영향 범위를 격리**한다

요약하면, MCP는 “통제/관측”을 유지하고 Tool은 “실행”을 맡아야 **운영 안정성**과 **확장성**이 확보됩니다.

단기 MVP에서의 타협(현실적인 예외)

- 초기 PoC/MVP 단계에서는 **Tool 수가 극히 적고** 장애 영향이 제한적일 수 있다.
- 이 경우 한시적으로 MCP가 실행을 일부 맡아 **구현 속도**를 높일 수 있다.
- 단, **확장 시점**에 반드시 Tool로 분리한다는 전제와 계획이 필요하다.

### 2-2) MCP가 되어야 하는 것

- **도구 발견/등록**: Tool 목록과 스키마 제공
- **접근 통제**: 인증/권한 체크를 일관되게 수행
- **호출 정책**: 제한, 동시성 제어, 회로 차단
- **관측 표준화**: 로그/감사/추적 필드를 강제

MCP는 “실행”이 아니라 **통제/관측/표준화**를 담당합니다. MCP가 맡아야 하는 이유는 다음과 같습니다.

- **정책 중앙화**: 인증/권한/레이트 리밋을 한 곳에서 관리하면 기준이 흔들리지 않는다.  
  Tool마다 정책이 다르면 **감사 기준**이 무너지고 운영이 복잡해진다.
- **관측 일관성**: trace_id, actor_id, tool_name 같은 필드를 **모든 호출에 강제**해야 한다.  
  MCP에서 강제하면 누락을 방지할 수 있다.
- **도구 카드 표준화**: 스키마/힌트/예시를 일관된 형식으로 제공해야 LLM 선택 품질이 높아진다.  
  MCP가 이를 표준으로 제공하면 Agent가 **예측 가능하게 동작**한다.
- **호출 정책 통일**: 레이트 리밋/동시성 제한/서킷 브레이커를 중앙에서 적용한다.  
  Tool마다 다른 기준을 두면 **재시도 폭주**나 **장애 전파**가 발생한다.
- **변경 통제**: 스키마 변경과 버전 노출을 MCP에서 통제해야 하위 호환을 유지할 수 있다.

실무에서 겪을 수 있는 예시

1) 특정 Tool에서 레이트 리밋 초과가 빈번하게 발생  
2) MCP가 호출 정책을 중앙에서 적용하면 **Tool 전체에 동일 기준**이 적용됨  
3) Agent의 호출 패턴이 안정되고, **로그/감사 기준도 일관**된다

요약하면, MCP는 **정책/가시성/표준화**를 담당하고 Tool은 **실행**만 담당해야 운영이 안정됩니다.

### 2-3) 구분 기준과 실무 판단 가이드

구분은 **범용성**이 아니라 **역할(실행 vs 통제)** 기준으로 한다.

핵심 질문

- 이 기능은 **실제 실행**인가, **호출 통제**인가?
- 실패했을 때 **재시도/회로 차단**은 어디에서 할 것인가?
- 감사/추적을 **표준으로 강제**해야 하는가?
- 실행 장애가 **다른 Tool에도 전파**되면 안 되는가?
- 스키마/정책 변경이 **중앙에서 일괄 적용**되어야 하는가?

실무에서 겪을 수 있는 예시(판단 흐름)

1) “ERP 조회”는 실행이므로 Tool에 둔다.  
2) 레이트 리밋/권한/감사는 MCP에서 중앙으로 강제한다.  
3) MCP가 실행까지 맡으면 ERP 장애가 **다른 Tool 호출에도 영향**을 준다.  
4) 따라서 실행은 Tool, 정책은 MCP로 분리한다.

헷갈릴 때의 기준

- **DB 조회는 Tool**이다.  
  DB를 직접 읽는 행위는 “실제 실행”이므로 Tool의 책임이다.
- **MCP는 실행을 하지 않는다.**  
  MCP는 Tool을 발견/등록하고, 접근 통제와 호출 정책을 강제한다.

공용 Tool 전환 기준 (체크리스트)

- **사용 빈도**: 여러 Agent가 반복적으로 호출하는가?
- **보안 민감도**: 권한/감사 정책을 공통으로 강제해야 하는가?
- **운영 비용**: 개별 Tool 유지 비용이 높아 공용화로 줄일 수 있는가?
- **변경 영향도**: 스키마 변경이 여러 팀에 영향을 주는가?
- **성능/한계**: 레이트 리밋, 동시성 제한을 공통으로 관리해야 하는가?

요약하면, 질문에 “통제/표준화가 필요하다”는 답이 많을수록 MCP,  
“실제 실행이 필요하다”는 답이 많을수록 Tool에 배치하는 것이 안전하다.

---

## 3. 공통 컴포넌트를 먼저 분리하라

Tool이 늘어날수록 “공통 기준”이 중요합니다.

- **스키마 검증 모듈**: 입력/출력 형식 검증
- **에러 매핑 모듈**: 내부 에러를 표준 코드로 변환
- **정책 모듈**: 재시도/타임아웃/멱등 키 규칙
- **관측 모듈**: trace_id, actor_id, tool_name 표준화
- **레지스트리**: Tool 등록과 버전 관리

이 구조가 있으면 Tool을 추가할 때 **새 코드가 최소화**됩니다.

---

## 4. Tool 등록과 LangGraph/LangChain 연동 예시

아래 예시는 Tool을 **LangChain 도구로 등록**하고, LangGraph 기반 에이전트에 연결하는 최소 흐름입니다.

```python
"""
목적: Tool을 등록하고 LangGraph 기반 에이전트에 연결하는 예시를 제공한다.
설명: @tool 데코레이터와 create_agent를 사용한다.
디자인 패턴: 커맨드
참조: LangChain Tool, LangGraph create_agent
"""

from langchain.tools import tool
from langchain.agents import create_agent


@tool
def erp_billing_summary(customer_id: str) -> str:
    """고객의 미결제 요약을 반환한다."""

    return f"{customer_id} 미결제 합계: 120000 KRW"


def build_agent():
    # model 값은 사용하는 제공자에 맞게 변경한다.
    return create_agent(
        model="provider:model-name",
        tools=[erp_billing_summary],
    )


agent = build_agent()
result = agent.invoke(
    {"messages": [{"role": "user", "content": "C-1001 미결제 요약 알려줘"}]}
)
```

실무 포인트

- Tool의 docstring/description이 **에이전트의 선택 품질**에 영향을 준다.
- 등록된 Tool은 **스키마가 고정**되어야 안정적으로 호출된다.
- LangGraph 기반 에이전트는 **Tool 목록을 그대로 사용**한다.

---

## 5. SI 기업 관점 실무 예시

### 5-1) 케이스: “고객 미결제 내역 조회”

**상황**

- SI 프로젝트에서 영업 담당자가 고객의 미결제 내역을 확인해야 한다.
- ERP와 CRM을 동시에 조회해야 하며 감사 로그가 필수다.

**구성**

- Tool: `erp_billing_query`, `crm_customer_profile`
- MCP: Tool 등록/검색, 권한 확인, 호출 제한, 감사 로그 표준화

**흐름**

1. Agent가 요청을 해석해 필요한 Tool을 결정한다.
2. MCP가 권한을 확인하고 허용된 Tool만 노출한다.
3. Tool이 ERP/CRM에서 데이터를 가져온다.
4. MCP가 결과에 trace_id를 붙이고 감사 로그를 남긴다.
5. Agent가 결과를 요약해 사용자에게 전달한다.

**실무 포인트**

- ERP/CRM 호출은 **동시성 제한**이 필요하다.
- Tool은 **읽기 전용**임을 명시해야 한다.
- MCP는 **감사 필드를 강제**해 누락을 방지한다.

---

## 6. Tool 설계 체크리스트

- Tool과 MCP의 책임이 분리되어 있는가?
- 입력/출력 스키마가 문서화되어 있는가?
- 에러 코드가 표준화되어 있는가?
- 멱등 키와 재시도 정책이 정의되어 있는가?
- 공통 컴포넌트가 분리되어 있는가?
- 운영 로그/감사가 일관되게 남는가?
